theory Semantics
  imports
  "Syntax"
  "Util"
  
begin
\<comment>\<open>We realise the semantics of GL, GLs, RGL, FLC, Lmu, LStar.\<close>

section \<open>Base defs: nbd structs, ground types, contexts, valuations\<close>

type_synonym ground_type = "int"
type_synonym 'a world_type = "'a set"
type_synonym 'a sub_world_type = "'a set"
type_synonym 'a eff_fn_type = "'a sub_world_type \<Rightarrow> 'a sub_world_type"

type_synonym atm_fmls = "Atm_fml set"
type_synonym atm_games = "Atm_game set"
type_synonym var_set_type = "int set"
type_synonym var_type = "int"

\<comment>\<open>monotone neighbourhood structure\<close>
record ('a) Nbd_Struct = 
  World :: "'a world_type"
  PropInterp :: "Atm_fml \<Rightarrow> 'a sub_world_type"
  GameInterp :: "Atm_game \<Rightarrow> 'a eff_fn_type"

\<comment>\<open>predicate to ensure monotone nbd structure is defined correctly.\<close>
definition is_nbd_struct :: "'a Nbd_Struct \<Rightarrow> bool" where
  "is_nbd_struct S \<equiv> 
    (World S \<noteq> {})
  \<and> (\<forall>g. ( (GameInterp S g) \<in> carrier_of (World S) \<inter> mono_of (World S) ))
  \<and> (\<forall>p. (PropInterp S p) \<subseteq> (World S)) "

lemma is_nbd_struct_compat [simp]: "is_nbd_struct N \<Longrightarrow> a = Agl_gm x1 \<Longrightarrow> GameInterp N x1 \<in> Pow (World N) \<rightarrow> Pow (World N)"
  apply (auto simp add:is_nbd_struct_def carrier_of_def)
  done
  
\<comment>\<open>valuation\<close>
type_synonym 'a val = "var_type \<Rightarrow> 'a eff_fn_type"

definition is_val :: "'a Nbd_Struct \<Rightarrow> 'a val \<Rightarrow> bool" where
  "is_val N I \<equiv> \<forall>i. I i \<in> effective_fn_of (World N)"

lemma val_modify_val: "f\<in>effective_fn_of (World N) \<Longrightarrow> is_val N I \<Longrightarrow> is_val N (I(x:=f))"
  by (simp add:is_val_def)

lemma val_modify_compat: "x=y \<Longrightarrow> (I(x:=a)) y = a &&& x\<noteq>y \<Longrightarrow> (I(x:=a)) y = I y"
  by linarith

\<comment>\<open>context\<close>
definition Sab :: "int set" where
  "Sab = {-1,0,1}"

type_synonym cx = "Atm_game \<Rightarrow> int"

definition ALL_CX :: "(Atm_game \<Rightarrow> int) set" where
"ALL_CX = \<int> \<rightarrow> Sab"

definition const1_cx :: "cx" where
  "const1_cx t = 1"

lemma ALL_CX_nonempty : "ALL_CX \<noteq> {}"
proof -
  have"const1_cx \<in> ALL_CX"
    apply (simp add:ALL_CX_def const1_cx_def)
    apply (auto simp add:const1_cx_def Sab_def)
    done
  then show ?thesis by auto
qed

definition is_cx :: "cx \<Rightarrow> bool" where
  "is_cx c \<equiv> c \<in> ALL_CX"

definition dual_cx :: "cx \<Rightarrow> cx" where
  "dual_cx cx = -cx"

definition subst_cx :: "cx \<Rightarrow> Atm_game \<Rightarrow> int \<Rightarrow> cx" where
  "subst_cx f a i b = (if a=b then i else f b)"

lemma subst_cx_compat [simp]:
  assumes "c\<in> ALL_CX"
  shows "subst_cx c a 1 \<in> ALL_CX \<and> subst_cx c a (-1)\<in> ALL_CX"
  apply (auto simp add:Sab_def ALL_CX_def subst_cx_def)
proof -
  show "\<And>x. x \<in> \<int> \<Longrightarrow> c x \<noteq> - 1 \<Longrightarrow> c x \<noteq> 0 \<Longrightarrow> a \<noteq> x \<Longrightarrow> c x = 1" using assms by (auto simp add:ALL_CX_def Sab_def)
  show "\<And>x. x \<in> \<int> \<Longrightarrow> c x \<noteq> - 1 \<Longrightarrow> c x \<noteq> 0 \<Longrightarrow> a \<noteq> x \<Longrightarrow> c x = 1" using assms by (auto simp add:ALL_CX_def Sab_def)
qed

lemma cx_double_neg: 
  assumes "c \<in> ALL_CX" shows "subst_cx c x (-1) = - subst_cx (- c) x 1" by (auto simp add:subst_cx_def)

lemma cx_neg_sub:
  assumes "c\<in> ALL_CX" shows "- (subst_cx c x t) = subst_cx (-c) x (-t)" by (auto simp add:subst_cx_def)

lemma cx_double_dual: 
  assumes "c\<in> ALL_CX" shows "dual_cx (dual_cx c) = c" using assms by (auto simp add:dual_cx_def)

lemma sab_negate_compat [simp]: "a\<in>Sab \<Longrightarrow> -a\<in>Sab" by (auto simp add:Sab_def)

lemma cx_negate_compat [simp]: 
  assumes "b\<in>ALL_CX"
  shows"-b\<in> ALL_CX"
  using assms by (auto simp add:ALL_CX_def Sab_def)

definition comp :: "'a set \<Rightarrow> 'a set \<Rightarrow> 'a set" where
  "comp w A = amb_comp w A"

lemma comp_compat [simp] : assumes "A \<subseteq> N" shows "comp N A\<subseteq> N" 
  using assms by (auto simp add:comp_def)

lemma comp_subset_is_diff [simp]: assumes "A\<subseteq>N" shows "comp N A = N - A"
  using assms unfolding comp_def amb_comp_def by auto

lemma comp_flip [simp]:
  assumes "a\<subseteq>b" and "a\<subseteq>N" and "b\<subseteq>N"
  shows "comp N b \<subseteq>comp N a"
  using assms comp_subset_is_diff
  by (metis Diff_mono order_refl)

lemma comp_invo [simp]:
  assumes "a\<subseteq> N"
  shows "comp N (comp N a) = a"
  using assms unfolding comp_def by auto

definition dual_eff_fn :: "'a Nbd_Struct  \<Rightarrow> 'a eff_fn_type \<Rightarrow> 'a eff_fn_type" where
  "dual_eff_fn N f A = Util.dual_eff_fn (World N) f A"

lemma dual_eff_fn_compat[simp]:
  fixes N :: "'a Nbd_Struct"
  and f:: "'a eff_fn_type"
  assumes "is_nbd_struct N" "f\<in>Pow (World N) \<rightarrow> Pow (World N)"
  shows "dual_eff_fn N f \<in> Pow (World N) \<rightarrow> Pow (World N)"
  using assms unfolding dual_eff_fn_def
  using funcset_dual_funcset[of "f" "World N"] by auto

lemma mono_dual_mono[simp]:
  fixes N :: "'a Nbd_Struct"
  and f:: "'a eff_fn_type"
assumes "f\<in> mono_of (World N)" and "f\<in> Pow (World N)\<rightarrow> Pow (World N)"
shows "dual_eff_fn N f \<in> mono_of (World N)"
  using assms mono_dual_mono[of "f""World N"] unfolding dual_eff_fn_def
  by auto

lemma extension_dual_extension [simp]:
  assumes "f \<in> extension (Pow (World N))" shows "dual_eff_fn N f \<in>  extension (Pow (World N))"
  using assms ext_dual_ext[of "f" "World N"] unfolding dual_eff_fn_def by auto

lemma effective_dual_effective [simp]:
  assumes "f \<in> effective_fn_of (World N)" and "is_nbd_struct N" shows "dual_eff_fn N f \<in> effective_fn_of (World N)"
  using assms by (simp add:effective_fn_of_def carrier_of_def)

lemma dual_eff_fn_invo [simp]:
  assumes "f \<in> effective_fn_of (World N)"
  shows "dual_eff_fn N (dual_eff_fn N f) = f"
  using assms
  unfolding dual_eff_fn_def
  using Util.dual_eff_fn_invo[of "f""World N"] by auto

definition eff_fn_fam_dual_closed where
  "eff_fn_fam_dual_closed N F \<equiv> \<forall>x\<in>F. (dual_eff_fn N x) \<in> F"

lemma all_eff_fn_dual_closed: assumes "is_nbd_struct N" shows "eff_fn_fam_dual_closed N (effective_fn_of (World N))"
  unfolding eff_fn_fam_dual_closed_def
  using effective_dual_effective[where N="N"] assms by auto

lemma dual_eff_fn_set_compre: 
  assumes "F\<subseteq> effective_fn_of (World N)" and "eff_fn_fam_dual_closed N F"
  shows "{u. u \<in> F} = {dual_eff_fn N u | u. u\<in> F}"
  apply auto
proof -
  fix x assume a:"x\<in>F"
  from assms a have "dual_eff_fn N x \<in> F" unfolding eff_fn_fam_dual_closed_def by auto
  then have "x = dual_eff_fn N (dual_eff_fn N x) \<and> (dual_eff_fn N x)\<in> F" using dual_eff_fn_invo[of "x" "N"] assms(1) a by force 
  then show "\<exists>u. x = dual_eff_fn N u \<and> u \<in> F" by auto
next
  fix u assume a:"u\<in>F"
  show "dual_eff_fn N u\<in> F" using assms(2) a unfolding eff_fn_fam_dual_closed_def by auto
qed

section \<open>The GLs extension of base \<close>

\<comment>\<open>World type is a cartesian product with context, instead of a ground set\<close>
type_synonym GLs_ground_type = "int \<times> cx"
type_synonym GLs_world_type = "GLs_ground_type world_type"
type_synonym GLs_sub_world_type = "GLs_ground_type sub_world_type"
type_synonym GLs_eff_fn_type = "GLs_sub_world_type \<Rightarrow> GLs_sub_world_type"


definition lift_game_interp :: "ground_type Nbd_Struct \<Rightarrow> (Atm_game \<Rightarrow> GLs_ground_type eff_fn_type)" where
"lift_game_interp N a (U::(int\<times>(int \<Rightarrow> int)) set)
  = (if U \<subseteq> World N \<times> ALL_CX 
    then {(w,c)\<in> World N \<times> ALL_CX. (c a = 0) \<and> (w \<in> (GameInterp N) a (fst ` U)) \<or> (c a = 1) \<and> ((w,c)\<in> U)}
    else undefined)"

lemma lift_game_interp_comat:
  fixes N :: "ground_type Nbd_Struct"
  and a :: "Atm_game"
assumes
  "is_nbd_struct N"
shows "lift_game_interp N a \<in> carrier_of (World N \<times> ALL_CX)"
  by (auto simp add:carrier_of_def lift_game_interp_def extension_def)

definition lift_prop_interp :: "ground_type Nbd_Struct \<Rightarrow> Atm_fml \<Rightarrow> GLs_ground_type sub_world_type" where
"lift_prop_interp N P = (PropInterp N P) \<times> ALL_CX"

definition GLs_lift_nbd :: "ground_type Nbd_Struct \<Rightarrow> GLs_ground_type Nbd_Struct" where
  "GLs_lift_nbd N = \<lparr> World=(World N)\<times>ALL_CX , 
    PropInterp = lift_prop_interp N,
    GameInterp = lift_game_interp N 
 \<rparr>"

definition sabo_comp :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_world_type \<Rightarrow> GLs_world_type" where
  "sabo_comp N A = (if A \<subseteq> World N then {(w,cx)\<in> World N. (w, dual_cx cx) \<notin> A } else {})"

lemma sabo_comp_compat : assumes "A\<subseteq> World N" shows "sabo_comp N A\<subseteq> World N" by (auto simp add:sabo_comp_def)

lemma sabo_comp_dm_andor : assumes "A\<subseteq>World N"
  and "B\<subseteq> World N"
shows "sabo_comp N (A \<inter> B) = sabo_comp N A \<union> sabo_comp N B" using assms by (auto simp add:sabo_comp_def)

lemma sabo_comp_dm_orand : assumes "A\<subseteq>World N"
and "B\<subseteq> World N"
shows "sabo_comp N (A \<union> B) = sabo_comp N A \<inter> sabo_comp N B" using assms by (auto simp add:sabo_comp_def)

lemma sabo_comp_dm_general_orand: assumes "\<Omega> \<subseteq> Pow (World N)"
  shows "ambient_inter (World N) {sabo_comp N A | A. A \<in> \<Omega>}=sabo_comp N (\<Union> \<Omega>)"
  apply (auto simp add:ambient_inter_def sabo_comp_def)
  by (metis (no_types, lifting) case_prod_conv empty_iff mem_Collect_eq)

lemma sabo_comp_dm_general_andor: assumes "\<Omega> \<subseteq> Pow (World N \<times> ALL_CX)"
  shows "sabo_comp (GLs_lift_nbd N) (ambient_inter (World (GLs_lift_nbd N)) \<Omega>) = \<Union> {sabo_comp (GLs_lift_nbd N) A| A. A\<in>\<Omega>}"
proof -
  consider (Emp) "\<Omega>={}" | (NEmp) "\<Omega>\<noteq>{}" by auto
  then show ?thesis
  proof cases
    case Emp
    then show ?thesis
    proof - 
      from Emp have LHS:"\<Union> {sabo_comp (GLs_lift_nbd N) A |A. A \<in> \<Omega>} = {}" by auto
      from Emp have RHS:"sabo_comp (GLs_lift_nbd N) (ambient_inter (World N\<times>ALL_CX) \<Omega>) = {}" 
        by (auto simp add: GLs_lift_nbd_def dual_cx_def ambient_inter_def sabo_comp_def)
      from LHS RHS show ?thesis by (simp add:GLs_lift_nbd_def)
    qed
  next
    case NEmp
    then show ?thesis
      apply (auto simp add: sabo_comp_def GLs_lift_nbd_def ambient_inter_def dual_cx_def)
      by (smt (verit, del_insts) Pow_def assms case_prodI mem_Collect_eq subset_iff)
  qed
qed

\<comment>\<open> Complement takes negative \<close>
lemma sabo_dbl_comp [simp] : 
  assumes "A \<subseteq> World N \<times> ALL_CX"
  shows "sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) A) = A"
  apply (auto simp add:sabo_comp_def dual_cx_def GLs_lift_nbd_def)
  using assms uminus_apply cx_double_dual dual_cx_def by auto
  
lemma set_sabo_comp : "{A. A\<subseteq> (World N \<times> ALL_CX) \<and> P A} 
  = {sabo_comp (GLs_lift_nbd N) A| A. sabo_comp (GLs_lift_nbd N) A \<subseteq> (World N \<times>ALL_CX) \<and> P (sabo_comp (GLs_lift_nbd N) A)}"
  apply auto
proof -
  fix x assume P1:"x \<subseteq> World N \<times> ALL_CX" and P2:"P x"
  show
    "\<exists>A. x = sabo_comp (GLs_lift_nbd N) A \<and> sabo_comp (GLs_lift_nbd N) A \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) A)"
  proof
    show "x = sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x)  \<and> sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))"
    proof
      from P1 show P3:"x = sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x)" using sabo_dbl_comp by auto
      show "sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))"
      proof 
        from P1 P3 show "sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX" by simp
        from P2 P3 show " P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))" by simp
      qed
    qed
  qed
qed

lemma set_sabo_comp2 : "{A. A\<subseteq> (World N \<times> ALL_CX) \<and> P A} 
  = {sabo_comp (GLs_lift_nbd N) A| A. A \<subseteq> (World N \<times>ALL_CX) \<and> P (sabo_comp (GLs_lift_nbd N) A)}"
  apply auto
proof -
  fix x assume P1:"x \<subseteq> World N \<times> ALL_CX" and P2:"P x"
  show
    "\<exists>A. x = sabo_comp (GLs_lift_nbd N) A \<and> A \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) A)"
  proof
    show "x = sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x)  \<and> (sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))"
    proof
      from P1 show P3:"x = sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x)" using sabo_dbl_comp by auto
      show "(sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX \<and> P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))"
      proof 
        from P1 show "(sabo_comp (GLs_lift_nbd N) x) \<subseteq> World N \<times> ALL_CX" using sabo_comp_compat[of "x" "GLs_lift_nbd N"] by (auto simp add:GLs_lift_nbd_def)
        from P2 P3 show " P (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) x))" by simp
      qed
    qed
  qed
next
  show "\<And>A a b. A \<subseteq> World N \<times> ALL_CX \<Longrightarrow> P (sabo_comp (GLs_lift_nbd N) A) \<Longrightarrow> (a, b) \<in> sabo_comp (GLs_lift_nbd N) A \<Longrightarrow> a \<in> World N"
    by (metis GLs_lift_nbd_def Nbd_Struct.select_convs(1) mem_Sigma_iff sabo_comp_compat subsetD)
next
  show "\<And>A a b. A \<subseteq> World N \<times> ALL_CX \<Longrightarrow> P (sabo_comp (GLs_lift_nbd N) A) \<Longrightarrow> (a, b) \<in> sabo_comp (GLs_lift_nbd N) A \<Longrightarrow> b \<in> ALL_CX "
  by (metis GLs_lift_nbd_def Nbd_Struct.select_convs(1) mem_Sigma_iff sabo_comp_compat subset_eq)
qed

lemma sabo_comp_homo : assumes "A\<subseteq>World N\<times> ALL_CX" and "B\<subseteq> World N\<times> ALL_CX"
shows "A\<subseteq>B \<longleftrightarrow> sabo_comp (GLs_lift_nbd N) B \<subseteq> sabo_comp (GLs_lift_nbd N) A"
  by (metis GLs_lift_nbd_def Nbd_Struct.select_convs(1) Un_Int_eq(1) sabo_comp_compat sabo_comp_dm_andor subset_Un_eq assms sabo_dbl_comp)

definition sabo_dual :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_eff_fn_type \<Rightarrow> GLs_eff_fn_type" where
  "sabo_dual N f A = sabo_comp N (f (sabo_comp N A))"

\<comment>\<open>function that substitutes atomic game "a" to Angelic control in context\<close>
definition GLs_game_subst :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_sub_world_type \<Rightarrow> Atm_game \<Rightarrow> GLs_sub_world_type" where
  "GLs_game_subst N A a = {(w,c)\<in> World N. (w,(subst_cx c a 1)) \<in> A}"

definition GLs_game_Dsubst :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_sub_world_type \<Rightarrow> Atm_game \<Rightarrow> GLs_sub_world_type" where
  "GLs_game_Dsubst N A a = {(w,c) \<in> World N. (w,(subst_cx c a (-1))) \<in> A}"

definition GLs_dual_eff_fn :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_eff_fn_type \<Rightarrow> GLs_eff_fn_type" where
"GLs_dual_eff_fn N f A = sabo_comp N (f (sabo_comp N A))"

lemma GLs_dual_eff_fn_compat:
  fixes N :: "ground_type Nbd_Struct"
    and f :: "GLs_eff_fn_type"
  assumes "is_nbd_struct N" "f\<in> Pow (World N \<times> ALL_CX) \<rightarrow> Pow (World N\<times> ALL_CX)" 
  shows "(GLs_dual_eff_fn (GLs_lift_nbd N) f) \<in> Pow (World N \<times> ALL_CX) \<rightarrow> Pow (World N\<times> ALL_CX)"
  apply (auto simp add:carrier_of_def GLs_lift_nbd_def GLs_dual_eff_fn_def sabo_comp_def)
    apply (metis (no_types, lifting) Nbd_Struct.select_convs(1) empty_def mem_Collect_eq mem_Sigma_iff old.prod.case)
   apply (metis (no_types, lifting) Nbd_Struct.select_convs(1) SigmaD2 empty_def mem_Collect_eq old.prod.case)
  done

lemma GLs_dual_eff_fn_demorgan : 
  assumes "A\<subseteq> World N" and "f\<in> Pow (World N) \<rightarrow> Pow (World N)" and "g\<in>Pow (World N) \<rightarrow> Pow (World N)"
  shows "GLs_dual_eff_fn N (\<lambda>x. f x \<inter> g x) A = GLs_dual_eff_fn N f A \<union> GLs_dual_eff_fn N g A"
proof -
  have "sabo_comp N A \<subseteq> World N" using assms(1) by (auto simp add:sabo_comp_def)
  then show ?thesis
    by (smt (verit) GLs_dual_eff_fn_def PiE Pow_iff assms(2,3) sabo_comp_dm_andor)
qed
  
lemma GLs_dual_eff_fn_composition:
  assumes "A\<subseteq> World N \<times> ALL_CX" and "f\<in> Pow (World N\<times>ALL_CX) \<rightarrow> Pow (World N\<times>ALL_CX)" and "g\<in>Pow (World N\<times>ALL_CX) \<rightarrow> Pow (World N\<times>ALL_CX)"
  shows "GLs_dual_eff_fn (GLs_lift_nbd N) (\<lambda>x. g (f x)) A = GLs_dual_eff_fn (GLs_lift_nbd N) g (GLs_dual_eff_fn (GLs_lift_nbd N) f A)"
  apply (simp add:GLs_dual_eff_fn_def)
proof -
  have "sabo_comp (GLs_lift_nbd N) A\<subseteq> World N \<times> ALL_CX" using sabo_comp_compat[of "A" "GLs_lift_nbd N"] assms(1) by (auto simp add:GLs_lift_nbd_def)
  then have "f (sabo_comp (GLs_lift_nbd N) A) \<subseteq> World (GLs_lift_nbd N)" using assms(2) by (auto simp add:GLs_lift_nbd_def)
  then have "f (sabo_comp (GLs_lift_nbd N) A) = sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) (f (sabo_comp (GLs_lift_nbd N) A)))" 
    using sabo_dbl_comp[of "f (sabo_comp (GLs_lift_nbd N) A)" "N"] by (auto simp add:GLs_lift_nbd_def)
  then show "sabo_comp (GLs_lift_nbd N) (g (f (sabo_comp (GLs_lift_nbd N) A))) =
    sabo_comp (GLs_lift_nbd N) (g (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) (f (sabo_comp (GLs_lift_nbd N) A)))))"
    by auto
qed

definition union :: "'a set \<Rightarrow> 'a set \<Rightarrow> 'a set" where
  "union A B = A\<union>B"

lemma union_mono : "\<forall>A::'a set. mono (union A)"
  apply (simp add:mono_def union_def)
  apply (auto)
  done

definition union2 :: "('a set \<Rightarrow> 'a set) \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set" where
  "union2 f A B = A \<union> f(B)"

definition inter:: "'a set \<Rightarrow> 'a set \<Rightarrow> 'a set" where
  "inter A B = A \<inter> B"

lemma set_double_diff: 
  fixes B:: "'a set" and A::"'a set"
  assumes "A \<subseteq> B"
  shows "B-(B-A) = A"
  by (simp add: assms double_diff)

lemma union_mono_strong: "\<forall>A. mono f \<Longrightarrow> mono (union2 f A)"
  apply (simp add:mono_def union2_def)
  apply (auto)
  done


lemma GLs_eff_fn_double_dual : 
  assumes "A \<subseteq> World N \<times> ALL_CX"
        "f \<in> Pow (World N \<times> ALL_CX) \<rightarrow> Pow (World N \<times> ALL_CX)"
  shows "GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_dual_eff_fn (GLs_lift_nbd N) f) A = f A"
  apply (simp add:GLs_dual_eff_fn_def assms)
proof -
  have "f A\<in> Pow (World N\<times> ALL_CX)" using assms by auto
  then show "sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) (f A)) = f A"
    by (simp add: assms GLs_dual_eff_fn_def)
qed


lemma carrier_lift_carrier : assumes "is_nbd_struct N"
  shows "GameInterp (GLs_lift_nbd N) g \<in> carrier_of (World (GLs_lift_nbd N))"
  apply (simp add:GLs_lift_nbd_def carrier_of_def extension_def)
  apply (auto simp add:lift_game_interp_def)
  
  done

lemma prop_lift_prop : assumes "is_nbd_struct N" 
  shows "PropInterp (GLs_lift_nbd N) p \<subseteq> World (GLs_lift_nbd N)"
  apply (simp add:GLs_lift_nbd_def lift_prop_interp_def)
  using assms apply (auto simp add:is_nbd_struct_def) done

lemma mono_lift_mono : 
  assumes "(GameInterp N g) \<in> mono_of (World N)"
  shows "(GameInterp (GLs_lift_nbd N) g) \<in> mono_of (World N\<times> ALL_CX)"
  apply (simp add: GLs_lift_nbd_def mono_of_def lift_game_interp_def)
  apply auto
proof - fix x y a b show "x \<subseteq> World N \<times> ALL_CX \<Longrightarrow>
       a \<in> World N \<Longrightarrow> y \<subseteq> World N \<times> ALL_CX \<Longrightarrow> x \<subseteq> y \<Longrightarrow> b \<in> ALL_CX \<Longrightarrow> b g = 0 \<Longrightarrow> a \<in> GameInterp N g (fst ` x) \<Longrightarrow> a \<in> GameInterp N g (fst ` y)"
  proof - assume P1:"x\<subseteq> World N\<times>ALL_CX" and P2:"y\<subseteq>World N\<times>ALL_CX" and P3:"x \<subseteq> y" and " b \<in> ALL_CX" and " b g = 0" and P4:"a \<in> GameInterp N g (fst ` x)"
    show "a \<in> GameInterp N g (fst ` y)"
    proof -
      from assms have Q:"\<forall>x y. x\<subseteq> World N \<and> y\<subseteq>World N \<and> x \<subseteq> y \<longrightarrow> GameInterp N g x \<subseteq> GameInterp N g y" by (simp add:mono_of_def)
      have "fst ` x\<subseteq> World N \<and> fst ` y\<subseteq> World N \<and> fst ` x \<subseteq> fst ` y" using P1 P2 P3 by auto
      then show ?thesis using P4 Q by auto
    qed
  qed
  fix x y a b
  assume P1:"x \<subseteq> World N \<times> ALL_CX " and "a \<in> World N" and P2:"y \<subseteq> World N \<times> ALL_CX" and P3:"x \<subseteq> y" and "b \<in> ALL_CX" and "b g = 0" and P4:"a \<in> GameInterp N g (fst ` x)"
  and "(a, b) \<notin> y"
  show "a \<in> GameInterp N g (fst ` y)"
  proof -
    from assms have Q:"\<forall>x y. x\<subseteq> World N \<and> y\<subseteq>World N \<and> x \<subseteq> y \<longrightarrow> GameInterp N g x \<subseteq> GameInterp N g y" by (simp add:mono_of_def)
    have "fst ` x\<subseteq> World N \<and> fst ` y\<subseteq> World N \<and> fst ` x \<subseteq> fst ` y" using P1 P2 P3 by auto
    then show ?thesis using P4 Q by auto
  qed
qed

lemma nbd_lift_nbd : assumes "is_nbd_struct N"
  shows "is_nbd_struct (GLs_lift_nbd N)"
  apply (simp add:is_nbd_struct_def)
proof 
  have "World N\<noteq>{} \<Longrightarrow> World (GLs_lift_nbd N) \<noteq> {}" apply (auto simp add:GLs_lift_nbd_def ALL_CX_nonempty) done
  then show "World (GLs_lift_nbd N) \<noteq> {}" using assms by (auto simp add:is_nbd_struct_def)

  from assms have P1:"\<forall>g. GameInterp N g \<in> carrier_of (World N) \<and> GameInterp N g \<in> mono_of (World N)"
    and P2:"\<forall>p. PropInterp N p \<subseteq> World N" by (auto simp add:is_nbd_struct_def)
  then have "
    (\<forall>g. GameInterp (GLs_lift_nbd N) g \<in> carrier_of (World (GLs_lift_nbd N)) \<and> GameInterp (GLs_lift_nbd N) g \<in> mono_of (World (GLs_lift_nbd N))) \<and>
    (\<forall>p. PropInterp (GLs_lift_nbd N) p \<subseteq> World (GLs_lift_nbd N))"
  proof - have R1:"(\<forall>g. GameInterp (GLs_lift_nbd N) g \<in> carrier_of (World (GLs_lift_nbd N)) \<and> GameInterp (GLs_lift_nbd N) g \<in> mono_of (World (GLs_lift_nbd N)))"
    proof fix g
      show "GameInterp (GLs_lift_nbd N) g \<in> carrier_of (World (GLs_lift_nbd N)) \<and> GameInterp (GLs_lift_nbd N) g \<in> mono_of (World (GLs_lift_nbd N))"
      proof -
        from P1 mono_lift_mono[of "N""g"] carrier_lift_carrier[of "N" "g"] show ?thesis using assms by (auto simp add:GLs_lift_nbd_def)
      qed
    qed

    have R2:"\<forall>p. PropInterp (GLs_lift_nbd N) p \<subseteq> World (GLs_lift_nbd N)" using assms P2 prop_lift_prop[of "N"] by auto
    show ?thesis using R1 R2 by auto
  qed
  thus "(\<forall>g. GameInterp (GLs_lift_nbd N) g \<in> carrier_of (World (GLs_lift_nbd N)) \<and> GameInterp (GLs_lift_nbd N) g \<in> mono_of (World (GLs_lift_nbd N))) \<and>
    (\<forall>p. PropInterp (GLs_lift_nbd N) p \<subseteq> World (GLs_lift_nbd N))" by simp
qed

fun GLs_fml_sem :: "GLs_ground_type Nbd_Struct \<Rightarrow> GLs_fml \<Rightarrow> GLs_sub_world_type"
 and GLs_game_sem :: "GLs_ground_type Nbd_Struct => GLs_game => GLs_eff_fn_type"
  where
  "GLs_fml_sem N (GLs_Atm_fml i) = PropInterp N i"
| "GLs_fml_sem N (GLs_Not f) = sabo_comp N (GLs_fml_sem N f)"
| "GLs_fml_sem N (GLs_Or f1 f2) = GLs_fml_sem N f1 \<union> GLs_fml_sem N f2"
| "GLs_fml_sem N (GLs_Mod g f) = (GLs_game_sem N g) (GLs_fml_sem N f)"

| "GLs_game_sem N (GLs_Atm_Game (Agl_gm i)) A = GameInterp N i A"
| "GLs_game_sem N (GLs_Atm_Game (Dmn_gm i)) A = GLs_dual_eff_fn N (GameInterp N i) A"
| "GLs_game_sem N (GLs_Test fml) A = (GLs_fml_sem N fml) \<inter> A "
| "GLs_game_sem N (GLs_Sabo (Agl_gm a)) A = GLs_game_subst N A a"
| "GLs_game_sem N (GLs_Sabo (Dmn_gm a)) A = GLs_game_Dsubst N A a"
| "GLs_game_sem N (GLs_Dual g) A = GLs_dual_eff_fn N (GLs_game_sem N g) A"
| "GLs_game_sem N (GLs_Choice a b) A = (GLs_game_sem N a A) \<union> (GLs_game_sem N b A)"
| "GLs_game_sem N (GLs_Seq a b) A = GLs_game_sem N b (GLs_game_sem N a A)"
| "GLs_game_sem N (GLs_Star a) A = ambient_inter (World N) { B \<in> Pow (World N). A \<union> GLs_game_sem N a B \<subseteq> B}"

lemma GLs_sem_wd:
  fixes N:: "ground_type Nbd_Struct"
  and f:: "GLs_fml"
  and g:: "GLs_game"
assumes "is_nbd_struct N"
shows "GLs_fml_sem (GLs_lift_nbd N) f \<subseteq> World N\<times> ALL_CX"
  "\<forall>A \<subseteq> (World N\<times> ALL_CX). GLs_game_sem (GLs_lift_nbd N) g A \<subseteq> (World N \<times> ALL_CX)"
proof (induction f and g)
  case (GLs_Atm_Game x)
  then show ?case
  proof (cases x)
    case (Agl_gm x1)
    then show ?thesis 
      using assms by (auto simp add:is_nbd_struct_def GLs_lift_nbd_def lift_game_interp_comat lift_game_interp_def)
  next
    case (Dmn_gm x2)
    then show ?thesis
      using assms GLs_dual_eff_fn_compat sabo_comp_compat
      by (auto simp add: sabo_comp_def is_nbd_struct_def GLs_dual_eff_fn_def GLs_lift_nbd_def lift_game_interp_comat lift_game_interp_def)
    qed
next
  case (GLs_Sabo x)
  then show ?case
  proof (cases x)
    case (Agl_gm x1)
    then show ?thesis 
    using assms apply (simp add:is_nbd_struct_def GLs_lift_nbd_def GLs_game_subst_def subst_cx_compat lift_game_interp_comat carrier_of_def)
    by blast
  next
    case (Dmn_gm x2)
    then show ?thesis 
    using assms apply (simp add:is_nbd_struct_def GLs_lift_nbd_def GLs_game_Dsubst_def subst_cx_compat lift_game_interp_comat carrier_of_def)
    by blast
  qed
next
  case (GLs_Dual x)
  then show ?case apply (simp add:is_nbd_struct_def)
    using GLs_dual_eff_fn_compat[of "N"] assms GLs_Dual by blast
next
  case (GLs_Test x)
  then show ?case by auto
next
  case (GLs_Choice x1 x2)
  then show ?case by auto
next
  case (GLs_Seq x1 x2)
  then show ?case by auto
next
  case (GLs_Star x)
  then show ?case by (simp add: GLs_lift_nbd_def Inter_lower ambient_inter_def)
next
  case (GLs_Atm_fml x)
  then show ?case using assms by (auto simp add:is_nbd_struct_def GLs_lift_nbd_def lift_prop_interp_def)
next
  case (GLs_Not x)
  then show ?case by (auto simp add:GLs_lift_nbd_def sabo_comp_def)
next
  case (GLs_Or x1 x2)
  then show ?case by auto
next
  case (GLs_Mod x1 x2)
  then show ?case by auto
qed

lemma GLs_And_sem : 
  assumes "is_nbd_struct N"
  shows "GLs_fml_sem (GLs_lift_nbd N) (GLs_And f1 f2) = GLs_fml_sem (GLs_lift_nbd N) f1 \<inter> GLs_fml_sem (GLs_lift_nbd N) f2"
  unfolding GLs_And_def apply simp
  using sabo_comp_dm_orand sabo_dbl_comp GLs_sem_wd[of "N"] sabo_comp_compat assms GLs_lift_nbd_def[of "N"] 
  by (metis Nbd_Struct.select_convs(1))

lemma GLs_DChoice_sem :
  assumes "is_nbd_struct N"
  and "A\<subseteq> World N \<times> ALL_CX"
shows "GLs_game_sem (GLs_lift_nbd N) (GLs_DChoice g1 g2) A = GLs_game_sem (GLs_lift_nbd N) g1 A \<inter> GLs_game_sem (GLs_lift_nbd N) g2 A"
  unfolding GLs_DChoice_def 
  using GLs_dual_eff_fn_def apply simp
  using assms sabo_dbl_comp[of "A" "N"] apply simp 
  using sabo_comp_dm_orand[of "sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g1 A)" 
      "GLs_lift_nbd N" "sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g2 A)"] sabo_dbl_comp
      sabo_comp_compat
  by (smt (verit) GLs_lift_nbd_def GLs_sem_wd(2) Nbd_Struct.select_convs(1))
  
lemma GLs_DTest_sem :
  assumes "is_nbd_struct N"
  and "A\<subseteq> World N \<times> ALL_CX"
shows "GLs_game_sem (GLs_lift_nbd N) (GLs_DTest f) A = A \<union> sabo_comp (GLs_lift_nbd N) (GLs_fml_sem (GLs_lift_nbd N) f)"
  unfolding GLs_DTest_def apply simp
  apply (simp add:GLs_dual_eff_fn_def)
  using sabo_comp_dm_andor sabo_dbl_comp
  by (metis GLs_lift_nbd_def GLs_sem_wd(1) Nbd_Struct.select_convs(1) assms(1,2) sabo_comp_compat sup_commute)

lemma GLs_DStar_sem: 
  assumes "is_nbd_struct N"
  and "A\<subseteq> World N \<times> ALL_CX"
shows "GLs_game_sem (GLs_lift_nbd N) (GLs_DStar g) A = \<Union> { B \<in> Pow (World N \<times>ALL_CX). B \<subseteq> A \<inter> GLs_game_sem (GLs_lift_nbd N) g B}"
  unfolding GLs_DStar_def apply (simp add:GLs_dual_eff_fn_def)
proof -
  let ?LHS = "sabo_comp (GLs_lift_nbd N)
     (ambient_inter (World (GLs_lift_nbd N))
       {B. B \<subseteq> World (GLs_lift_nbd N) \<and>
           sabo_comp (GLs_lift_nbd N) A \<subseteq> B \<and> sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g (sabo_comp (GLs_lift_nbd N) B)) \<subseteq> B})"
  let ?RHS = "\<Union> {B. B \<subseteq> World N \<times> ALL_CX \<and> B \<subseteq> A \<and> B \<subseteq> GLs_game_sem (GLs_lift_nbd N) g B}"
  from sabo_comp_dm_general_andor[of "{B. B \<subseteq> World (GLs_lift_nbd N) \<and>
           sabo_comp (GLs_lift_nbd N) A \<subseteq> B \<and> sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g (sabo_comp (GLs_lift_nbd N) B)) \<subseteq> B}" "N"] 
  have a1:"
    ?LHS
    = \<Union> {sabo_comp (GLs_lift_nbd N) B| B. B \<subseteq> World (GLs_lift_nbd N) \<and>
           sabo_comp (GLs_lift_nbd N) A \<subseteq> B \<and> sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g (sabo_comp (GLs_lift_nbd N) B)) \<subseteq> B}
  " by (auto simp add:GLs_lift_nbd_def)
  also have "... = \<Union> {sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) B)| B. B \<subseteq> World (GLs_lift_nbd N) \<and>
           sabo_comp (GLs_lift_nbd N) A \<subseteq> sabo_comp (GLs_lift_nbd N) B 
            \<and> sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g (sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) B))) \<subseteq> sabo_comp (GLs_lift_nbd N) B}"
    using set_sabo_comp2[of "N"] GLs_lift_nbd_def
  by (smt (verit, ccfv_SIG) Collect_cong Nbd_Struct.select_convs(1) sabo_comp_compat sabo_dbl_comp)
  also have "... = \<Union> {B. B \<subseteq> World (GLs_lift_nbd N) \<and>
           sabo_comp (GLs_lift_nbd N) A \<subseteq> sabo_comp (GLs_lift_nbd N) B 
            \<and> sabo_comp (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g B) \<subseteq> sabo_comp (GLs_lift_nbd N) B}"
    using sabo_dbl_comp[where N="N"] GLs_lift_nbd_def[of "N"]
    by (metis (lifting) Nbd_Struct.select_convs(1))
  also have "... = \<Union> {B. B \<subseteq> World (GLs_lift_nbd N) \<and> B\<subseteq>A \<and> B\<subseteq>GLs_game_sem (GLs_lift_nbd N) g B }" 
    using sabo_comp_homo[where N="N"] assms(2) GLs_lift_nbd_def[of "N"]
    by (metis (lifting) GLs_sem_wd(2)[of N g] Nbd_Struct.select_convs(1)[of "World N \<times> ALL_CX" "lift_prop_interp N" "lift_game_interp N" "()"] assms(1))
  finally show "?LHS = ?RHS" using GLs_lift_nbd_def by auto
qed

lemma GLs_sy_comp_dual_compat :
  fixes N:: "ground_type Nbd_Struct"
  and f:: "GLs_fml"
  and g:: "GLs_game"
  and A:: "GLs_ground_type set"
assumes "is_nbd_struct N"
shows "GLs_fml_sem (GLs_lift_nbd N) (GLs_sy_comp f) = sabo_comp (GLs_lift_nbd N) (GLs_fml_sem (GLs_lift_nbd N) f)"
   "\<forall>A \<subseteq> (World N\<times> ALL_CX). GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual g) A = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) g) A"
proof (induction f and g)
  case (GLs_Atm_Game x)
  then show ?case
  proof (cases x)
    case (Agl_gm x1)
    then show ?thesis by auto
  next
    case (Dmn_gm x2)
    then show ?thesis
      apply (simp add:GLs_dual_eff_fn_def) 
      apply rule
    proof fix A assume b0: "x=Dmn_gm x2" and a0:"A\<subseteq> World N\<times>ALL_CX"
      from a0 have a1:"sabo_comp (GLs_lift_nbd N) (sabo_comp (GLs_lift_nbd N) A) = A" 
        using sabo_dbl_comp by (auto simp add:GLs_lift_nbd_def)

      from a0 have a2:"GameInterp (GLs_lift_nbd N) x2 A\<subseteq> World N\<times> ALL_CX" 
        using assms by (auto simp add:is_nbd_struct_def carrier_of_def GLs_lift_nbd_def lift_game_interp_def)

      then show "GameInterp (GLs_lift_nbd N) x2 A =
          sabo_comp (GLs_lift_nbd N)
          (sabo_comp (GLs_lift_nbd N) (GameInterp (GLs_lift_nbd N) x2 A))"
        using a1 a2 sabo_dbl_comp by auto
    qed
  qed
next
  case (GLs_Sabo x)
  then show ?case
  proof (cases x)
    case (Agl_gm x1)
    then show ?thesis 
      apply (simp add:GLs_dual_eff_fn_def GLs_game_Dsubst_def GLs_game_subst_def)
      apply rule
    proof fix A assume a1:"x = Agl_gm x1" and a2:"A\<subseteq>World N\<times> ALL_CX"
      let ?LHS = "{(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx c x1 (- 1)) \<in> A}"
      let ?RHS = "sabo_comp (GLs_lift_nbd N) {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx c x1 1) \<in> sabo_comp (GLs_lift_nbd N) A}"
      have "?RHS = sabo_comp (GLs_lift_nbd N) {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx (- c) x1 (-1)) \<notin> A}"
        using sabo_comp_def dual_cx_def a2 cx_neg_sub cx_double_dual GLs_lift_nbd_def subst_cx_compat by auto
      also have "... = {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, dual_cx c) \<notin> {(w,c). (w, subst_cx (- c) x1 (-1)) \<notin> A} }"
        using sabo_comp_def GLs_lift_nbd_def apply auto
        using cx_negate_compat dual_cx_def by fastforce
      also have "... = ?LHS"
        using cx_double_dual dual_cx_def GLs_lift_nbd_def by auto
      finally show "?LHS = ?RHS" by auto
    qed
  next
    case (Dmn_gm x2)
    then show ?thesis
      apply (simp add:GLs_dual_eff_fn_def GLs_game_Dsubst_def GLs_game_subst_def)
      apply rule
    proof fix A assume a1:"x=Dmn_gm x2" and a2:"A\<subseteq> World N\<times>ALL_CX"
      let ?LHS = "{(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx c x2 1) \<in> A}"
      let ?RHS = "sabo_comp (GLs_lift_nbd N) {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx c x2 (- 1)) \<in> sabo_comp (GLs_lift_nbd N) A}"
      have "?RHS = sabo_comp (GLs_lift_nbd N) 
        {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, subst_cx (-c) x2 1) \<notin> A}"
        using sabo_comp_def dual_cx_def a2 cx_neg_sub cx_double_dual GLs_lift_nbd_def subst_cx_compat by auto
      also have "... = {(w, c). (w, c) \<in> World (GLs_lift_nbd N) \<and> (w, dual_cx c) \<notin> {(w,c). (w, subst_cx (- c) x2 1) \<notin> A} }"
        using sabo_comp_def GLs_lift_nbd_def apply auto
        using cx_negate_compat dual_cx_def by fastforce
      also have "... = ?LHS" 
        using cx_double_dual dual_cx_def GLs_lift_nbd_def by auto
      finally show "?LHS = ?RHS" by auto
    qed
  qed
next
  case (GLs_Dual x)
  then show ?case using GLs_eff_fn_double_dual
    by (simp add: GLs_sem_wd(2) assms)
next
  case (GLs_Test x)
  then show ?case 
    by (simp add:GLs_DTest_def GLs_dual_eff_fn_def)
next
  case (GLs_Choice x1 x2)
  then show ?case apply (simp add:GLs_DChoice_def GLs_dual_eff_fn_def)
    using sabo_dbl_comp
    by (metis GLs_lift_nbd_def GLs_sem_wd(2) Nbd_Struct.select_convs(1) assms sabo_comp_compat)
next
  case (GLs_Seq x1 x2)
  then show ?case 
  proof - assume a1:"\<forall>A\<subseteq>World N \<times> ALL_CX. GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x1) A = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x1) A"
    and a2:"\<forall>A\<subseteq>World N \<times> ALL_CX. GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x2) A = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x2) A"
    show "\<forall>A\<subseteq> World N\<times> ALL_CX. GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual (GLs_Seq x1 x2)) A = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) (GLs_Seq x1 x2)) A"
      apply (simp)
      apply rule
    proof
      fix A assume a3:" A\<subseteq> World N\<times> ALL_CX"
      from a1 a3 
      have a1':"GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x1) A = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x1) A" by auto
      
      from a3 GLs_sem_wd(2)[of "N""x1"] assms(1) have b1:"GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x1) A \<subseteq> World N\<times> ALL_CX" by (metis GLs_game_sem.simps(6) GLs_sem_wd(2))

      then have "GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x2) (GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x1) A) = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x2) (GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) x1) A)"
        using a2 a1' by auto
      then show "GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x2) (GLs_game_sem (GLs_lift_nbd N) (GLs_sy_dual x1) A) = GLs_dual_eff_fn (GLs_lift_nbd N) (GLs_game_sem (GLs_lift_nbd N) (GLs_Seq x1 x2)) A"
        using GLs_dual_eff_fn_composition assms is_nbd_struct_def carrier_of_def a3 GLs_dual_eff_fn_def GLs_sem_wd(2) by auto
    qed
  qed
next
  case (GLs_Star x)
  then show ?case 
    apply (simp add:GLs_DStar_def GLs_dual_eff_fn_def)
    using sabo_comp_dm_general_andor sabo_comp_homo sabo_dbl_comp GLs_lift_nbd_def sabo_comp_compat assms GLs_sem_wd
    by (smt (verit, ccfv_SIG) Collect_cong Nbd_Struct.select_convs(1))
next
  case (GLs_Atm_fml x)
  then show ?case by auto
next
  case (GLs_Not x)
  then show ?case apply simp
    using sabo_dbl_comp GLs_sem_wd(1)[of "N""x"] assms by auto
next
  case (GLs_Or x1 x2)
  then show ?case
    using GLs_And_def apply (simp)
    using sabo_dbl_comp sabo_comp_dm_orand GLs_sem_wd(1) sabo_comp_compat assms
    by simp
next
  case (GLs_Mod x1 x2)
  then show ?case
    by (metis GLs_dual_eff_fn_def GLs_fml_sem.simps(4) GLs_sem_wd(1) GLs_sy_comp.simps(4) assms sabo_dbl_comp)
qed

section \<open>The RGL extension of base, with world structure un-modified\<close>
type_synonym RGL_var_type = "int"
type_synonym RGL_ground_type = "int"
type_synonym RGL_world_type = "RGL_ground_type world_type"
type_synonym RGL_sub_world_type = "RGL_ground_type sub_world_type"
type_synonym RGL_eff_fn_type = "RGL_sub_world_type \<Rightarrow> RGL_sub_world_type"


(*g , [g]: States \<rightarrow> States. [g](A) = those states that angel has strategy to reach A *)
\<comment>\<open>RGL semantics\<close>
fun RGL_fml_sem :: "RGL_ground_type Nbd_Struct \<Rightarrow> RGL_var_type val \<Rightarrow> RGL_var_type RGL_fml \<Rightarrow> RGL_sub_world_type"
  and RGL_game_sem :: "RGL_ground_type Nbd_Struct \<Rightarrow> RGL_var_type val \<Rightarrow> RGL_var_type RGL_game \<Rightarrow> RGL_eff_fn_type"
  where
  "RGL_fml_sem N I (RGL_Atm_fml fl) = PropInterp N fl"
| "RGL_fml_sem N I (RGL_Not fl) = (World N) - (RGL_fml_sem N I fl)"
| "RGL_fml_sem N I (RGL_Or fl1 fl2) = (RGL_fml_sem N I fl1) \<union> (RGL_fml_sem N I fl2)"
| "RGL_fml_sem N I (RGL_Mod g fl) = (RGL_game_sem N I g) (RGL_fml_sem N I fl)"
| "RGL_game_sem N I (RGL_Atm_Game (Agl_gm a)) A = GameInterp N a A"
| "RGL_game_sem N I (RGL_Atm_Game (Dmn_gm a)) A = (dual_eff_fn N (GameInterp N a)) A"
| "RGL_game_sem N I (RGL_Var x) A = I x A"
| "RGL_game_sem N I (RGL_Dual g) A = (dual_eff_fn N (RGL_game_sem N I g)) A"
| "RGL_game_sem N I (RGL_Test fl) A = (if A \<subseteq> (World N) then (RGL_fml_sem N I fl) \<inter> A else undefined)"
| "RGL_game_sem N I (RGL_Choice g1 g2) A = (RGL_game_sem N I g1 A) \<union> (RGL_game_sem N I g2 A)"
| "RGL_game_sem N I (RGL_Seq g1 g2) A = compo (Pow (World N)) (RGL_game_sem N I g2) (RGL_game_sem N I g1) A"
| "RGL_game_sem N I (RGL_Rec x g) A =  (Lfp (World N) (\<lambda>u. (RGL_game_sem N (I(x:=u)) g))) A" (* rx.g *)

lemma RGL_Test_sem_eff: 
  assumes "is_nbd_struct N"
        "RGL_fml_sem N I f\<subseteq> World N"
      shows "RGL_game_sem N I (RGL_Test f) \<in> effective_fn_of (World N)"
  apply (simp add:effective_fn_of_def carrier_of_def)
proof
  show "RGL_game_sem N I (RGL_Test f) \<in> Pow (World N) \<rightarrow> Pow (World N)" by auto
  show "RGL_game_sem N I (RGL_Test f) \<in> extension (Pow (World N)) \<and> RGL_game_sem N I (RGL_Test f) \<in> mono_of (World N) "
  proof
    show "RGL_game_sem N I (RGL_Test f) \<in> extension (Pow (World N))" by (simp add:extension_def)
    show "RGL_game_sem N I (RGL_Test f) \<in> mono_of (World N)" by (auto simp add:mono_of_def)
  qed
qed

lemma RGL_Choice_sem: "RGL_game_sem N I (RGL_Choice g1 g2) = (\<lambda>A. (RGL_game_sem N I g1 A) \<union> (RGL_game_sem N I g2 A))"
  by auto
lemma RGL_Choice_sem_eff:
  assumes "is_nbd_struct N" and "RGL_game_sem N I g1 \<in> effective_fn_of (World N)" and "RGL_game_sem N I g2 \<in> effective_fn_of (World N)"
  shows "RGL_game_sem N I (RGL_Choice g1 g2) \<in> effective_fn_of (World N)" 
    using assms eff_union_eff[of "RGL_game_sem N I g1" "World N" "RGL_game_sem N I g2"] RGL_Choice_sem[of "N""I""g1""g2"] by auto

lemma RGL_sem_wd:
  fixes N :: "RGL_ground_type Nbd_Struct"
  and I :: "RGL_var_type val"
assumes "is_nbd_struct N"
    and "is_val N I"
  shows
    "(RGL_fml_sem N I f) \<subseteq> (World N)"
    "(RGL_game_sem N I g) \<in> effective_fn_of (World N)"
proof (induction f and g)
  case (RGL_Atm_Game x)
  then show ?case
  proof (cases x)
    case (Agl_gm x1)
    then show ?thesis using assms by (auto simp add:is_nbd_struct_def effective_fn_of_def)
  next
    case (Dmn_gm x2)
    then show ?thesis using assms by (auto simp add:is_nbd_struct_def effective_fn_of_def carrier_of_def)
  qed
next
  case (RGL_Var x)
  then show ?case using assms by (auto simp add: is_val_def effective_fn_of_def carrier_of_def)
next
  case (RGL_Dual x)
  then show ?case using assms dual_eff_fn_compat RGL_Dual.IH effective_dual_effective by auto
next
  case (RGL_Test f)
  then show ?case using RGL_Test_sem_eff[of "N" "I" "f"] assms RGL_Test.prems by blast
next
  case (RGL_Choice g1 g2)
  then show ?case using RGL_Choice_sem_eff assms by blast
next
  case (RGL_Seq g1 g2)
  then show ?case using eff_compo_eff by auto
next
  case (RGL_Rec x g)
  then show ?case using Lfp_eff by auto
next
  case (RGL_Atm_fml x)
  then show ?case using assms by (auto simp add:is_nbd_struct_def)
next
  case (RGL_Not x)
  then show ?case by auto
next
  case (RGL_Or x1 x2)
  then show ?case by auto
next
  case (RGL_Mod g f)
  then show ?case by (auto simp add:effective_fn_of_def carrier_of_def)
qed

lemma RGL_Test_sem__fml_compat: 
  assumes "is_nbd_struct N" and "is_val N I" and "is_val N J"
  shows "RGL_game_sem N I (RGL_Test f1) = RGL_game_sem N J (RGL_Test f2) \<Longrightarrow> RGL_fml_sem N I f1 = RGL_fml_sem N J f2"
proof - assume "RGL_game_sem N I (RGL_Test f1) = RGL_game_sem N J (RGL_Test f2)"
  then have a:"\<And>A. A\<subseteq> World N \<Longrightarrow> (RGL_fml_sem N I f1) \<inter> A = (RGL_fml_sem N J f2) \<inter> A"
    by (metis RGL_game_sem.simps(5))
  from RGL_sem_wd(1) assms have a1:"(RGL_fml_sem N I f1)\<subseteq> World N" by auto
  from RGL_sem_wd(1) assms have a2:"(RGL_fml_sem N J f2)\<subseteq> World N" by auto
  from a[of "RGL_fml_sem N I f1"] a1 have b1:"RGL_fml_sem N I f1\<subseteq> RGL_fml_sem N J f2" by auto
  from a[of "RGL_fml_sem N J f2"] a2 have b2:"RGL_fml_sem N J f2\<subseteq> RGL_fml_sem N I f1" by auto
  from b1 b2 show ?thesis by auto
qed

lemma RGL_DChoice_sem: 
  assumes "is_nbd_struct N" and "is_val N I"
shows"RGL_game_sem N I (RGL_DChoice g1 g2) A = RGL_game_sem N I g1 A \<inter> RGL_game_sem N I g2 A"
  unfolding RGL_DChoice_def apply (simp add:dual_eff_fn_def)
  unfolding Util.dual_eff_fn_def apply simp
  apply rule 
proof
  assume a:"A\<subseteq> World N"
  then have a2:"(World N - (World N-A)) = A" by auto
  then have b1:"RGL_game_sem N I g1 A \<subseteq> World N" using RGL_sem_wd(2)[of "N""I""g1"] assms by (auto simp add:effective_fn_of_def carrier_of_def)

  from a have b2:"RGL_game_sem N I g2 A\<subseteq> World N" using RGL_sem_wd(2)[of "N""I""g2"] assms by (auto simp add:effective_fn_of_def carrier_of_def)

  from a2 b1 b2 amb_comp_def amb_comp_compat a
  show "amb_comp (World N)
     (Semantics.dual_eff_fn N (RGL_game_sem N I g1) (amb_comp (World N) A) \<union> Semantics.dual_eff_fn N (RGL_game_sem N I g2) (amb_comp (World N) A)) =
    RGL_game_sem N I g1 A \<inter> RGL_game_sem N I g2 A"
    unfolding dual_eff_fn_def Util.dual_eff_fn_def
    by (smt (verit) Diff_Un le_sup_iff set_double_diff)
next
  show "\<not> A\<subseteq> World N \<longrightarrow> undefined = RGL_game_sem N I g1 A \<inter> RGL_game_sem N I g2 A"
  proof
    assume a:"\<not> A\<subseteq> World N"
  from RGL_sem_wd(2)[of "N""I""g1"] assms have c1:"RGL_game_sem N I g1 \<in> extension (Pow (World N))" by (auto simp add:effective_fn_of_def carrier_of_def)
  from RGL_sem_wd(2)[of "N""I""g2"] assms have c2:"RGL_game_sem N I g2 \<in> extension (Pow (World N))" by (auto simp add:effective_fn_of_def carrier_of_def)
    show "undefined = RGL_game_sem N I g1 A \<inter> RGL_game_sem N I g2 A" using c1 c2 a by (auto simp add:extension_def)
  qed
qed

lemma RGL_var_interp_mono [simp]: assumes "fun_le u v"
  shows "fun_le (RGL_game_sem N (I(x:=u)) (RGL_Var y)) (RGL_game_sem N (I(x:=v)) (RGL_Var y))"
  by (metis (lifting) ext RGL_game_sem.simps(3) assms fun_le_def fun_upd_other fun_upd_same subset_iff)

lemma RGL_closed_game_free_var [simp]: assumes "RGL_game_closed (RGL_Rec x g)"
  shows "free_var_game g = {x} \<or> RGL_game_closed g"
  using assms
proof (induction g rule:RGL_game_induct)
  case (RGL_Atm_Game a)
  then show ?case by (auto simp add:RGL_game_closed_def)
next
  case (RGL_Var y)
  then show ?case
  proof (cases "x=y")
    case True
    then show ?thesis by auto
  next
    case False
    then show ?thesis using RGL_Var.prems by (auto simp add:RGL_game_closed_def)
  qed
next
  case (RGL_Dual g)
  then show ?case by (auto simp add:RGL_game_closed_def)
next
  case (RGL_Test f)
  then show ?case by (auto simp add:RGL_game_closed_def)
next
  case (RGL_Choice g1 g2)
  then show ?case by (auto simp add:RGL_game_closed_def)
next
  case (RGL_Seq g1 g2)
  then show ?case by (auto simp add:RGL_game_closed_def)
next
  case (RGL_Rec x g)
  then show ?case by (auto simp add:RGL_game_closed_def)
qed

lemma RGL_Rec_sem_uniform: "RGL_game_sem N (I(x:=u)) (RGL_Rec x g) = RGL_game_sem N (I(x:=v)) (RGL_Rec x g)"
  by auto

lemma RGL_sem_local:
  "\<forall>x \<in> free_var_game g. I x = J x \<Longrightarrow> RGL_game_sem N I g = RGL_game_sem N J g"
  "\<And>K L. (\<forall>x \<in> free_var f. K x = L x \<Longrightarrow> RGL_fml_sem N K f = RGL_fml_sem N L f)"
proof (induction g and f arbitrary: I J)
  case (RGL_Atm_Game x)
  then show ?case apply (cases x) by auto
next
  case (RGL_Var y)
  then show ?case 
  proof - have "free_var_game (RGL_Var y) = {y}" by auto
    then show ?thesis using RGL_Var.prems by auto
  qed
next
  case (RGL_Dual g')
  then show ?case
  proof - have "free_var_game g' = free_var_game (RGL_Dual g')" by auto
    then have "\<forall>x \<in> free_var_game g'. I x = J x" using RGL_Dual.prems by auto
    then show ?thesis using RGL_Dual.IH
    using RGL_game_sem.simps(4) by presburger
  qed
next
  case (RGL_Test f')
  then show ?case 
  proof - have "free_var f' = free_var_game (RGL_Test f')" by auto
    then show ?thesis using RGL_Test.IH[of "I" "J"] RGL_Test.prems
      apply auto
      by presburger
  qed
next
  case (RGL_Choice g1 g2)
  then show ?case
  proof -
    have a1:"free_var_game g1\<subseteq> free_var_game (RGL_Choice g1 g2)" by auto
    have a2:"free_var_game g2\<subseteq> free_var_game (RGL_Choice g1 g2)" by auto

    from a1 have b1:"\<forall>x\<in>free_var_game g1. I x = J x" using RGL_Choice.prems by auto
    from a2 have b2:"\<forall>x\<in>free_var_game g2. I x = J x" using RGL_Choice.prems by auto

    from b1 b2 RGL_Choice.IH show ?thesis by force
  qed
next
  case (RGL_Seq g1 g2)
  then show ?case
  proof -
    have a1:"free_var_game g1\<subseteq> free_var_game (RGL_Choice g1 g2)" by auto
    have a2:"free_var_game g2\<subseteq> free_var_game (RGL_Choice g1 g2)" by auto

    from a1 have b1:"\<forall>x\<in>free_var_game g1. I x = J x" using RGL_Seq.prems by auto
    from a2 have b2:"\<forall>x\<in>free_var_game g2. I x = J x" using RGL_Seq.prems by auto

    from b1 b2 RGL_Seq.IH show ?thesis by force    
  qed
next
  case (RGL_Rec x g')
  then show ?case 
  proof -
    have a:"free_var_game g' - {x} = free_var_game (RGL_Rec x g')" by auto
    then have "\<And> u y. y\<in>free_var_game g' \<Longrightarrow> (I(x:=u)) y = (J(x:=u)) y" using RGL_Rec.prems by auto
    then have "\<And> u. RGL_game_sem N (I(x:=u)) g' = RGL_game_sem N (J(x:=u)) g'" using RGL_Rec.IH by auto
    then show ?thesis by auto
  qed
next
  case (RGL_Atm_fml x)
  then show ?case by auto
next
  case (RGL_Not x)
  then show ?case by auto
next
  case (RGL_Or f1 f2)
  then show ?case 
  proof -
    have a1:"free_var f1\<subseteq> free_var (RGL_Or f1 f2)" by auto
    have a2:"free_var f2\<subseteq> free_var (RGL_Or f1 f2)" by auto

    from a1 have b1:" \<forall>x\<in>free_var f1. K x = L x" using RGL_Or.prems by auto
    from a2 have b2:" \<forall>x\<in>free_var f2. K x = L x" using RGL_Or.prems by auto

    from RGL_Or.IH b1 b2 show ?thesis by force
  qed
next
  case (RGL_Mod g f)
  then show ?case
  proof - 
    have a1:"free_var_game g \<subseteq> free_var (RGL_Mod g f)" by auto
    have a2:"free_var f \<subseteq> free_var (RGL_Mod g f)" by auto

    from RGL_Mod.prems a1 have b1:"\<forall>x\<in>free_var_game g. K x = L x" by auto
    from RGL_Mod.prems a2 have b2:"\<forall>x\<in>free_var f. K x = L x" by auto

    from b1 b2 RGL_Mod.IH show ?thesis by force
  qed
qed

lemma RGL_closed_sem_uniform:
  "RGL_fml_closed f \<Longrightarrow> RGL_fml_sem N K f = RGL_fml_sem N L f"
  "RGL_game_closed g \<Longrightarrow> RGL_game_sem N I g = RGL_game_sem N J g"
proof -
  assume "RGL_fml_closed f"
  then have "free_var f = {}" by (simp add:RGL_fml_closed_def)
  then have "\<forall>x \<in> free_var f. K x = L x" by simp
  then show R2:"RGL_fml_sem N K f = RGL_fml_sem N L f" using RGL_sem_local by simp
next
  assume "RGL_game_closed g"
  then have "free_var_game g = {}" by (simp add:RGL_game_closed_def)
  then have "\<forall>x \<in> free_var_game g. I x = J x" by simp
  then show "RGL_game_sem N I g = RGL_game_sem N J g" using RGL_sem_local by simp
qed

definition RGL_fixpt_op:: "RGL_ground_type Nbd_Struct \<Rightarrow> RGL_var_type val \<Rightarrow> RGL_var_type \<Rightarrow> RGL_var_type RGL_game \<Rightarrow> RGL_eff_fn_type \<Rightarrow> RGL_eff_fn_type" where
  "RGL_fixpt_op N I x g u = RGL_game_sem N (I(x:=u)) g"

definition RGL_fixpt_dual_op:: "RGL_ground_type Nbd_Struct \<Rightarrow> RGL_var_type val \<Rightarrow> RGL_var_type \<Rightarrow> RGL_var_type RGL_game \<Rightarrow> RGL_eff_fn_type \<Rightarrow> RGL_eff_fn_type" where
  "RGL_fixpt_dual_op N I x g u = dual_eff_fn N (RGL_game_sem N (I(x:=u)) g)"

lemma RGL_Rec_sem [simp]: "RGL_game_sem N I (RGL_Rec x g) A = Lfp (World N) (RGL_fixpt_op N I x g) A"
  unfolding RGL_fixpt_op_def by simp

lemma RGL_fixpt_op_homo_dual: 
  assumes "is_nbd_struct N" and "is_val N I" and "u\<in> effective_fn_of (World N)"
  shows "RGL_game_sem N (I(x:=u)) (RGL_dual_free x g) = RGL_game_sem N (I(x:= dual_eff_fn N u)) g"
  using assms(2) assms(3)
proof (induction g arbitrary:I rule: RGL_game_induct_finer)
  case (RGL_Atm_Game a)
  then show ?case apply (cases a) by auto
next
  case (RGL_Var y)
  then show ?case
  proof (cases "x=y")
    case True
    then show ?thesis
    proof (auto)
      assume a:"x = y"
      have "RGL_game_sem N (\<lambda>a. if a = y then u else I a) (RGL_Var y) = u" by auto
      then show "dual_eff_fn N (RGL_game_sem N (\<lambda>a. if a = y then u else I a) (RGL_Var y)) = dual_eff_fn N u" by simp
    qed
  next
    case False
    then show ?thesis using RGL_sem_local(1)[of "RGL_Var y" "I(x := u)" "I(x := dual_eff_fn N u)" "N"] by auto
  qed
next
  case (RGL_Dual g1)
  then show ?case by auto
next
  case (RGL_Choice g1 g2)
  then show ?case by auto
next
  case (RGL_Seq g1 g2)
  then show ?case by auto
next
  case (RGL_Rec y g)
  then show ?case
  proof (cases "x=y")
    case True
    then show ?thesis
    proof -
      have a:"RGL_dual_free x (RGL_Rec y g) = RGL_Rec y g" using True by auto
      then have b:"RGL_game_sem N (I(x := u)) (RGL_dual_free x (RGL_Rec y g)) = RGL_game_sem N (I(x:=u)) (RGL_Rec y g)" by auto
      
      have "free_var_game (RGL_Rec y g) = free_var_game g - {y}" by auto
      then have "x\<notin> free_var_game (RGL_Rec y g)" using True by auto
      then have "\<forall>z\<in> free_var_game (RGL_Rec y g). (I(x:=u)) z = (I(x:= dual_eff_fn N u)) z" by auto
      then have "RGL_game_sem N (I(x := u)) (RGL_Rec y g) = RGL_game_sem N (I(x := dual_eff_fn N u)) (RGL_Rec y g)" using RGL_sem_local(1)[of "RGL_Rec y g" "I(x := u)" "I(x := dual_eff_fn N u)" "N"] by auto
      then show ?thesis using b by argo
    qed
  next
    case False
    then show ?thesis apply auto
    proof - from False have a1:"\<And>ua. (\<lambda>a. if a = x then u else I a)(y := ua) = (I(y:=ua, x:=u))" by auto
       from False have a2:"\<And>ua. (\<lambda>a. if a = x then dual_eff_fn N u else I a)(y := ua) = I(y:=ua, x:=dual_eff_fn N u)" by auto
       from RGL_Rec.IH a1 a2 
       have "\<And> ua. ua\<in> effective_fn_of (World N) \<Longrightarrow> RGL_game_sem N ((\<lambda>a. if a = x then u else I a)(y := ua)) (RGL_dual_free x g) = RGL_game_sem N ((\<lambda>a. if a = x then dual_eff_fn N u else I a)(y := ua)) g" using RGL_Rec.prems val_modify_val assms(3)
         by fastforce
       then have "\<And> a. {\<phi> a |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). fun_le (RGL_game_sem N ((\<lambda>a. if a = x then u else I a)(y := \<phi>)) (RGL_dual_free x g)) \<phi>}} 
          = {\<phi> a |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). fun_le (RGL_game_sem N ((\<lambda>a. if a = x then dual_eff_fn N u else I a)(y := \<phi>)) g) \<phi>}}" by auto
       then show "Lfp (World N) (\<lambda>ua. RGL_game_sem N ((\<lambda>a. if a = x then u else I a)(y := ua)) (RGL_dual_free x g)) = Lfp (World N) (\<lambda>ua. RGL_game_sem N ((\<lambda>a. if a = x then dual_eff_fn N u else I a)(y := ua)) g)"
         unfolding Lfp_def Lfp_family_def
         using ambient_inter_eq[where U="World N"]
       by presburger
    qed
  qed
next
  case (RGL_Atm_fml f)
  then show ?case
    by (metis RGL_closed_sem_uniform(2) RGL_dual_free.simps(7) RGL_dual_free_fml.simps(1) RGL_game_closed_def free_var.simps(1) free_var_game.simps(4))
next
  case (RGL_Not f)
  then show ?case
  proof (simp)
    assume a:"(\<And>I. is_val N I \<Longrightarrow> (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f \<inter> a else undefined))"
      and a_val:"is_val N I" and a_u:"u \<in> effective_fn_of (World N)"
    show "(\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_Not (RGL_dual_free_fml x f)) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (RGL_Not f) \<inter> a else undefined)"
      apply rule apply simp
    proof fix s assume b:"s\<subseteq> World N"
      from a[of "I"] b RGL_Not.prems(1) have b1:"RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f) \<inter> s = RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f \<inter> s" by meson
      from b1
      show "(World N - RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f)) \<inter> s = (World N - RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f) \<inter> s" by blast
    qed
  qed
next
  case (RGL_Or f1 f2)
  then show ?case
  proof (simp)
    assume a1:"(\<And>I. is_val N I \<Longrightarrow> (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f1) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f1 \<inter> a else undefined))"
      and a2:"(\<And>I. is_val N I \<Longrightarrow> (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f2) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f2 \<inter> a else undefined))"
      and a_val:"is_val N I" and a_u:"u \<in> effective_fn_of (World N)"
    have b_l:"RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_Or (RGL_dual_free_fml x f1) (RGL_dual_free_fml x f2)) = RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f1) \<union> RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f2)" by auto
    have b_r:"RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (RGL_Or f1 f2) = RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (f1) \<union> RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (f2)" by auto

    show "(\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_Or (RGL_dual_free_fml x f1) (RGL_dual_free_fml x f2)) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (RGL_Or f1 f2) \<inter> a else undefined)"
      apply rule apply simp
    proof fix s assume b:"s\<subseteq> World N"
      from a1[of "I"] RGL_Or.prems(1) have b1:"RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f1) \<inter> s = RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f1 \<inter> s" using b by meson
      from a2[of "I"] RGL_Or.prems(1) have b2:"RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f2) \<inter> s = RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f2 \<inter> s" using b by meson
      from b1 b2
      show "(RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f1) \<union> RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f2)) \<inter> s =
         (RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f1 \<union> RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f2) \<inter> s" by blast
    qed
  qed
next
  case (RGL_Mod g f)
  then show ?case 
  proof (simp)
    assume a_g: "(\<And>I. is_val N I \<Longrightarrow> RGL_game_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free x g) = RGL_game_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) g)"
      and a_f: "(\<And>I. is_val N I \<Longrightarrow> (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f \<inter> a else undefined))"
    show "(\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_Mod (RGL_dual_free x g) (RGL_dual_free_fml x f)) \<inter> a else undefined) = (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) (RGL_Mod g f) \<inter> a else undefined)"
      apply rule apply simp
    proof fix s assume a_s:"s\<subseteq> World N"
      have a:"I(x:=u) = (\<lambda>a. if a = x then u else I a)" by auto
      have "is_val N (I(x:=u))" using val_modify_val[of "u" "N" "I" "x"] RGL_Mod.prems by auto
      then have b:"RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f) \<subseteq> World N" 
        using RGL_sem_wd(1)[of "N""\<lambda>a. if a = x then u else I a" "RGL_dual_free_fml x f"] assms(1) RGL_Mod.prems a by auto
      
      from a RGL_Mod.IH(1)[of "\<lambda>a. if a = x then u else I a"] RGL_Mod.prems val_modify_val[of "u" "N" "I" "x"]
      have a3:"RGL_game_sem N ((\<lambda>a. if a = x then u else I a)(x := u)) (RGL_dual_free x g) = RGL_game_sem N ((\<lambda>a. if a = x then u else I a)(x := dual_eff_fn N u)) g" by fastforce

      have "(\<lambda>a. if a = x then u else I a)(x := u) = (\<lambda>a. if a = x then u else I a)" by auto
      from RGL_Mod.prems(1) have "RGL_game_sem N (I(x := u)) (RGL_dual_free x (RGL_Test f)) = RGL_game_sem N (I(x := dual_eff_fn N u)) (RGL_Test f)"
        using RGL_Mod.IH(2) assms(3) by blast
      then have "RGL_fml_sem N (I(x:=u)) (RGL_dual_free_fml x f) = RGL_fml_sem N (I(x := dual_eff_fn N u)) f" using RGL_Mod.prems val_modify_val[where I="I"]
        assms(1) by (simp add: RGL_Test_sem__fml_compat)
      then show "RGL_game_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free x g) (RGL_fml_sem N (\<lambda>a. if a = x then u else I a) (RGL_dual_free_fml x f)) \<inter> s =
         RGL_game_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) g (RGL_fml_sem N (\<lambda>a. if a = x then dual_eff_fn N u else I a) f) \<inter> s" using a
      by (smt (verit) RGL_sem_local(1,2) a3 fun_upd_other fun_upd_same)
    qed
  qed
qed

(* Utility function showing semantics of Rec *)
lemma RGL_Dual_sem:"RGL_game_sem N I (RGL_Dual g) = dual_eff_fn N (RGL_game_sem N I g)" by auto

(* RGL_fixpt_op, which is used in sem of Rec, is indeed a transformation between effective functions. *)
lemma RGL_fixpt_op_eff: 
  assumes "is_nbd_struct N" and "is_val N I"
  shows "RGL_fixpt_op N I x g \<in> op_of (World N)"
  unfolding op_of_def RGL_fixpt_op_def 
  using RGL_sem_wd(2) assms val_modify_val[where N="N" and I="I" and x="x"] by simp

(* semantics of r'x.a is greatest fixed point *)
lemma RGL_DRec_sem:
  assumes "is_nbd_struct N" and "is_val N I"
  shows "RGL_game_sem N I (RGL_DRec x g) = Gfp (World N) (RGL_fixpt_op N I x g)"
  unfolding RGL_DRec_def dual_eff_fn_def
proof fix A show "RGL_game_sem N I (RGL_Dual (RGL_Rec x (RGL_Dual (RGL_dual_free x g)))) A = Gfp (World N) (RGL_fixpt_op N I x g) A"
    apply simp
    unfolding dual_eff_fn_def
  proof -
    let ?LHS = "Util.dual_eff_fn (World N) (RGL_game_sem N I (RGL_Rec x (RGL_Dual (RGL_dual_free x g)))) A"
    let ?RHS = "Gfp (World N) (RGL_fixpt_op N I x g) A"
    have "RGL_game_sem N I (RGL_Rec x (RGL_Dual (RGL_dual_free x g))) = Lfp (World N) (RGL_fixpt_op N I x (RGL_Dual (RGL_dual_free x g)))"
      unfolding RGL_fixpt_op_def by auto
    then have "?LHS = Util.dual_eff_fn (World N) (Lfp (World N) (RGL_fixpt_op N I x (RGL_Dual (RGL_dual_free x g)))) A" by auto
    also have "... = Gfp (World N) (dual_op (World N) (RGL_fixpt_op N I x (RGL_Dual (RGL_dual_free x g)))) A"
      using dual_Lfp__Gfp_dualop[of "RGL_fixpt_op N I x (RGL_Dual (RGL_dual_free x g))""World N"] RGL_fixpt_op_eff[of "N""I""x""RGL_Dual (RGL_dual_free x g)"] assms by auto
    also have "... = Gfp (World N) (\<lambda>f. Util.dual_eff_fn (World N) (dual_eff_fn N (RGL_game_sem N (I(x := Util.dual_eff_fn (World N) f)) (RGL_dual_free x g)))) A"
      unfolding dual_op_def RGL_fixpt_op_def using RGL_Dual_sem by auto
    also have "... = Gfp (World N) (\<lambda>f. Util.dual_eff_fn (World N) (Util.dual_eff_fn (World N) (RGL_game_sem N (I(x := Util.dual_eff_fn (World N) f)) (RGL_dual_free x g)))) A"
      unfolding dual_eff_fn_def by simp
    also have "... = Gfp (World N) (RGL_fixpt_op N I x g) A"
      using RGL_fixpt_op_homo_dual[where N= "N" and I="I" and x="x" and g="g"] assms dual_eff_fn_invo
      unfolding Gfp_def Gfp_family_def RGL_fixpt_op_def dual_eff_fn_def
      by (smt (verit, ccfv_SIG) Collect_cong RGL_sem_wd(2) eff_dual_eff val_modify_val)
    finally show "?LHS=?RHS" by auto
  qed
qed


(*lemma 3.5 of paper: If rx.\<alpha> is valid, then u\<rightarrow>N[\<alpha>]^I(x:=u) is monotone.
  uses induction on normal form.*)
lemma RGL_fixpt_op_mono:
  fixes f:: "RGL_var_type RGL_fml"
    and g:: "RGL_var_type RGL_game"
    and N:: "RGL_ground_type Nbd_Struct"
    and I:: "RGL_var_type val"
    and x:: "RGL_var_type"
    and h:: "RGL_var_type RGL_game"
  assumes "RGL_gm_nodual x h" and "is_nbd_struct N" and "is_val N I"
  shows "RGL_fixpt_op N I x h \<in> monotone_op_of (World N)"
  using assms
proof (induction h arbitrary:I rule: RGL_gm_nodual_induct[where ?x="x"])
  case (atm a)
  then show ?case 
  proof (cases a)
    case (Agl_gm x1)
    then show ?thesis
      using assms
      by (simp add:RGL_fixpt_op_def is_nbd_struct_def monotone_op_of_def fun_le_def effective_fn_of_def)
  next
    case (Dmn_gm x2)
    then show ?thesis 
      using assms
      by (simp add:RGL_fixpt_op_def is_nbd_struct_def monotone_op_of_def fun_le_def effective_fn_of_def carrier_of_def)
  qed
next
  case (var y)
  then show ?case
    using assms by (auto simp add:RGL_fixpt_op_def is_val_def monotone_op_of_def fun_le_def)
next
  case (dvar y)
  then show ?case
  proof -
    consider (Eq) "x=y" | (Neq) "x\<noteq>y" by auto
      then show ?thesis
      proof cases
        case Eq
        from dvar(1) Eq have False apply cases unfolding RGL_DTest_def RGL_DChoice_def RGL_DRec_def by auto
        then show ?thesis by simp
        next
        case Neq
        then have a1:"\<And>a. (I(x:=a)) y = I y" using val_modify_compat by simp
        show ?thesis
          apply (simp add:RGL_fixpt_op_def local.dvar)
        proof -
          from Neq have a:"(\<lambda>a. dual_eff_fn N (RGL_game_sem N (I(x := a)) (RGL_Var y)) ) = (\<lambda>a. dual_eff_fn N (I y))"
            using RGL_game_sem.simps(3) a1 by presburger

          have "(\<lambda>a. dual_eff_fn N (I y)) \<in> monotone_op_of (World N)"
          proof -
            from assms(3) dvar.prems is_val_def[of "N" "I"] have "I y \<in> effective_fn_of (World N)" by auto
            then have a:"dual_eff_fn N (I y)\<in> effective_fn_of (World N)" using effective_dual_effective[of "I y" "N"] assms by auto
            then show ?thesis by (auto simp add:monotone_op_of_def fun_le_def)
          qed

          then show "(\<lambda>a. dual_eff_fn N (RGL_game_sem N (I(x := a)) (RGL_Var y))) \<in> monotone_op_of (World N)"
            using a by simp
        qed
      qed
   qed
next
  case (tst f) (* h = RGL_Test f. Then interpretation does not depend on x. *)
  then show ?case
    unfolding monotone_op_of_def RGL_fixpt_op_def apply auto
  proof -
    from tst.prems(1) have "RGL_fml_closed f" apply cases unfolding RGL_DTest_def RGL_DChoice_def RGL_DRec_def by auto
    then have "\<And> N I J. RGL_fml_sem N I f = RGL_fml_sem N J f" using RGL_closed_sem_uniform by auto
    fix xa assume a:"xa \<in> effective_fn_of (World N)"
    have "(\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (I(x := xa)) f \<inter> a else undefined) = RGL_game_sem N (I(x:=xa)) (RGL_Test f)" by auto
    then show "(\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (I(x := xa)) f \<inter> a else undefined) \<in> effective_fn_of (World N)" 
      using a RGL_sem_wd(2)[of "N""I(x:=xa)""RGL_Test f"] val_modify_val[of "xa""N""I""x"]  assms(2) tst.prems by auto
  next
    fix g1 g2 
    from tst.prems(1) have a:"RGL_fml_closed f" apply cases unfolding RGL_DTest_def RGL_DChoice_def RGL_DRec_def by auto
    from RGL_closed_sem_uniform(1)[of "f""N""I(x:=g1)""I(x:=g2)"] a
    show "fun_le (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (I(x := g1)) f \<inter> a else undefined) (\<lambda>a. if a \<subseteq> World N then RGL_fml_sem N (I(x := g2)) f \<inter> a else undefined)"
      unfolding fun_le_def by auto
  qed
next
  case (dtst f) 
  then show ?case unfolding monotone_op_of_def RGL_fixpt_op_def RGL_DTest_def apply auto
  proof -
    from dtst.prems(1) have "RGL_fml_closed f" apply cases unfolding RGL_DTest_def RGL_DChoice_def RGL_DRec_def by auto
    then have "\<And> N I J. RGL_fml_sem N I f = RGL_fml_sem N J f" using RGL_closed_sem_uniform by auto
    fix xa assume a:"xa \<in> effective_fn_of (World N)"
    then show "dual_eff_fn N (RGL_game_sem N (I(x := xa)) (RGL_Test f)) \<in> effective_fn_of (World N)"
      using a RGL_sem_wd(2)[of "N""I(x:=xa)""RGL_Test f"] val_modify_val[of "xa""N""I""x"]  assms(2) dtst.prems by auto
  next
    fix g1 g2 
    from dtst.prems(1) have a:"RGL_fml_closed f" apply cases unfolding RGL_DTest_def RGL_DChoice_def RGL_DRec_def by auto
    from RGL_closed_sem_uniform(1)[of "f""N""I(x:=g1)""I(x:=g2)"] a
    have b1:"RGL_game_sem N (I(x := g1)) (RGL_Test f) = (\<lambda>a. if a \<subseteq> (World N) then (RGL_fml_sem N (I(x := g1)) f) \<inter> a else undefined)" by auto
    have b2:"RGL_game_sem N (I(x := g2)) (RGL_Test f) = (\<lambda>a. if a \<subseteq> (World N) then (RGL_fml_sem N (I(x := g2)) f) \<inter> a else undefined)" by auto
    show "fun_le (dual_eff_fn N (RGL_game_sem N (I(x := g1)) (RGL_Test f))) (dual_eff_fn N (RGL_game_sem N (I(x := g2)) (RGL_Test f)))"
      unfolding fun_le_def using b1 b2 RGL_closed_sem_uniform(1)[of "f" "N" "I(x:=g1)" "I(x:=g2)"] a
    by (metis subset_iff_psubset_eq)
  qed
next
  case (choi g1 g2)
  then show ?case unfolding RGL_fixpt_op_def monotone_op_of_def apply auto
  proof -
    fix xa assume a0:"xa \<in> effective_fn_of (World N)"
    have b1:"RGL_game_sem N (I(x := xa)) g1 \<in> effective_fn_of (World N)" 
      using a0 RGL_sem_wd(2)[of "N""I(x:=xa)"] assms(2) choi.prems val_modify_val[of "xa" "N" "I" "x"] by auto
    have b2:"RGL_game_sem N (I(x := xa)) g2 \<in> effective_fn_of (World N)" 
      using a0 RGL_sem_wd(2)[of "N""I(x:=xa)"] assms(2) choi.prems val_modify_val[of "xa" "N" "I" "x"] by auto
    from b1 b2 show "(\<lambda>a. RGL_game_sem N (I(x := xa)) g1 a \<union> RGL_game_sem N (I(x := xa)) g2 a) \<in> effective_fn_of (World N)"
      using eff_union_eff[of "RGL_game_sem N (I(x := xa)) g1" "World N" "RGL_game_sem N (I(x := xa)) g2"] by auto
  next
    fix x1 x2 assume a:"fun_le x1 x2" and a1:"x1 \<in> effective_fn_of (World N)" and a2:"x2 \<in> effective_fn_of (World N)"
    and b1:"(\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g1) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1a\<in>effective_fn_of (World N).
                 \<forall>g2\<in>effective_fn_of (World N). fun_le g1a g2 \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1a)) g1) (RGL_game_sem N (I(x := g2)) g1)))"
    and b2:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g2) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and> 
             (\<forall>g1\<in>effective_fn_of (World N). 
                \<forall>g2a\<in>effective_fn_of (World N). fun_le g1 g2a \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1)) g2) (RGL_game_sem N (I(x := g2a)) g2))"
    
    from a b1 a1 a2 choi.prems have c1:"fun_le (RGL_game_sem N (I(x := x1)) g1) (RGL_game_sem N (I(x := x2)) g1)" by auto
    from a b2 a1 a2 choi.prems have c2:"fun_le (RGL_game_sem N (I(x := x1)) g2) (RGL_game_sem N (I(x := x2)) g2)" by auto

    from c1 c2
    show "fun_le (\<lambda>a. RGL_game_sem N (I(x := x1)) g1 a \<union> RGL_game_sem N (I(x := x1)) g2 a) (\<lambda>a. RGL_game_sem N (I(x := x2)) g1 a \<union> RGL_game_sem N (I(x := x2)) g2 a)"
      unfolding fun_le_def by force
  qed
next
  case (dchoi g1 g2)
  then show ?case unfolding RGL_fixpt_op_def monotone_op_of_def apply auto
  proof -
    fix xa assume a0:"xa \<in> effective_fn_of (World N)"
    show "RGL_game_sem N (I(x := xa)) (RGL_DChoice g1 g2) \<in> effective_fn_of (World N)" 
      using RGL_sem_wd(2)[of "N""I(x:=xa)" "RGL_DChoice g1 g2"] val_modify_val[of "xa""N""I""x"] assms(2) dchoi.prems a0 by auto
  next
    fix x1 x2 assume a:"fun_le x1 x2" and a1:"x1 \<in> effective_fn_of (World N)" and a2:"x2 \<in> effective_fn_of (World N)"
    and b1:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g1) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1a\<in>effective_fn_of (World N).
                 \<forall>g2\<in>effective_fn_of (World N). fun_le g1a g2 \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1a)) g1) (RGL_game_sem N (I(x := g2)) g1))"
    and b2:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g2) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1\<in>effective_fn_of (World N).
                 \<forall>g2a\<in>effective_fn_of (World N). fun_le g1 g2a \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1)) g2) (RGL_game_sem N (I(x := g2a)) g2))"

    from a b1 a1 a2 dchoi.prems have c1:"fun_le (RGL_game_sem N (I(x := x1)) g1) (RGL_game_sem N (I(x := x2)) g1)" by auto
    from a b2 a1 a2 dchoi.prems have c2:"fun_le (RGL_game_sem N (I(x := x1)) g2) (RGL_game_sem N (I(x := x2)) g2)" by auto

    from c1 c2
    show "fun_le (RGL_game_sem N (I(x := x1)) (RGL_DChoice g1 g2)) (RGL_game_sem N (I(x := x2)) (RGL_DChoice g1 g2))"
      unfolding fun_le_def using RGL_DChoice_sem[of "N"] val_modify_val[where N="N"] a1 a2 assms(2) dchoi.prems  by force
  qed
next
  case (seq g1 g2)
  then show ?case unfolding RGL_fixpt_op_def monotone_op_of_def apply auto
  proof -
    fix xa assume a0:"xa \<in> effective_fn_of (World N)"
    have a1:"RGL_game_sem N (I(x := xa)) g1 \<in> effective_fn_of (World N)" using a0 RGL_sem_wd assms(2) seq.prems val_modify_val by fastforce
    have a2:"RGL_game_sem N (I(x := xa)) g2 \<in> effective_fn_of (World N)" using a0 RGL_sem_wd assms(2) seq.prems val_modify_val by fastforce    
    show "compo (Pow (World N)) (RGL_game_sem N (I(x := xa)) g2) (RGL_game_sem N (I(x := xa)) g1) \<in> effective_fn_of (World N)"
      using eff_compo_eff[of "RGL_game_sem N (I(x := xa)) g1" "World N" "RGL_game_sem N (I(x := xa)) g2"] a1 a2 by auto
  next
    fix x1 x2 assume a1:"x1\<in> effective_fn_of (World N)" and a2:"x2\<in> effective_fn_of (World N)" and a:"fun_le x1 x2"
    and b1:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g1) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1a\<in>effective_fn_of (World N).
                 \<forall>g2\<in>effective_fn_of (World N). fun_le g1a g2 \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1a)) g1) (RGL_game_sem N (I(x := g2)) g1))"
    and b2:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) g2) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1\<in>effective_fn_of (World N).
                 \<forall>g2a\<in>effective_fn_of (World N). fun_le g1 g2a \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1)) g2) (RGL_game_sem N (I(x := g2a)) g2))"

    from b1 a1 a2 a seq.prems have c1:"fun_le (RGL_game_sem N (I(x := x1)) g1) (RGL_game_sem N (I(x := x2)) g1)" by auto
    from b2 a1 a2 a seq.prems have c2:"fun_le (RGL_game_sem N (I(x := x1)) g2) (RGL_game_sem N (I(x := x2)) g2)" by auto

    have d11:"RGL_game_sem N (I(x := x1)) g1 \<in> effective_fn_of (World N)" 
      using RGL_sem_wd(2)[of "N" "I(x:=x1)" "g1"] assms(2) seq.prems val_modify_val[of "x1" "N" "I""x"] a1 by auto
    have d12:"RGL_game_sem N (I(x := x2)) g1 \<in> effective_fn_of (World N)" 
      using RGL_sem_wd(2)[of "N" "I(x:=x2)" "g1"] assms(2) seq.prems val_modify_val[of "x2" "N" "I""x"] a2 by auto
    have d21:"RGL_game_sem N (I(x := x1)) g2 \<in> effective_fn_of (World N)" 
      using RGL_sem_wd(2)[of "N" "I(x:=x1)" "g2"] assms(2) seq.prems val_modify_val[of "x1" "N" "I""x"] a1 by auto
    have d22:"RGL_game_sem N (I(x := x2)) g2 \<in> effective_fn_of (World N)"
      using RGL_sem_wd(2)[of "N" "I(x:=x2)" "g2"] assms(2) seq.prems val_modify_val[of "x2" "N" "I""x"] a2 by auto    
    show "fun_le (compo (Pow (World N)) (RGL_game_sem N (I(x := x1)) g2) (RGL_game_sem N (I(x := x1)) g1)) (compo (Pow (World N)) (RGL_game_sem N (I(x := x2)) g2) (RGL_game_sem N (I(x := x2)) g1))"
      using c1 c2 d11 d12 d21 d22 compo_preserve_fun_le by force
  qed
next
  case (rec y h1)
  then show ?case (* h = ry.h1 When x=y then x is bdd in h1 then interpretation is independent of x. when x\<noteq>y use IH *)
    unfolding RGL_fixpt_op_def monotone_op_of_def apply auto
  proof -
    fix xa assume a0:"xa \<in> effective_fn_of (World N)"
    have a:"RGL_game_sem N (I(x := xa)) (RGL_Rec y h1) = Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := xa, y := u)) h1)" by auto
    show "Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := xa, y := u)) h1) \<in> effective_fn_of (World N)"
      using a a0 RGL_sem_wd(2)[of "N""I(x:=xa)""RGL_Rec y h1"] val_modify_val[of "xa""N""I""x"] assms(2) rec.prems by auto
  next
    fix g1 g2 assume a:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) h1) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1\<in>effective_fn_of (World N).
                 \<forall>g2\<in>effective_fn_of (World N). fun_le g1 g2 \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1)) h1) (RGL_game_sem N (I(x := g2)) h1))"
    and a1:"g1 \<in> effective_fn_of (World N)" and a2:"g2 \<in> effective_fn_of (World N)" and a0:"fun_le g1 g2"
    show conc:"fun_le (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g1, y := u)) h1)) (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g2, y := u)) h1))"
    proof (cases "x=y")
      case True
      then show ?thesis unfolding fun_le_def
      proof -
        assume ass:"x=y"
        show "\<forall> xb. Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g1, y := u)) h1) xb \<subseteq> Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g2, y := u)) h1) xb"
        proof fix xb
        from True have c1:"\<And>u. I(x:=g1, y:=u) = I(x:=u)" by auto
        from True have c2:"\<And>u. I(x:=g2, y:=u) = I(x:=u)" by auto
        from c1 c2
        show "Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g1, y := u)) h1) xb \<subseteq> Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g2, y := u)) h1) xb"
          by force
        qed
      qed
    next
      case False
      then show ?thesis
      proof -
        assume ass:"x\<noteq>y"
        show "fun_le (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g1, y := u)) h1)) (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g2, y := u)) h1))"
        proof -
          have a4:"\<And>u. u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(x:=g1,y:=u)) h1) (RGL_game_sem N (I(x:=g2,y := u)) h1)"
          proof - fix u
            have c1:"I(y := u, x := g1) = I(x:=g1,y:=u)" by (metis ass fun_upd_twist)
            have c2:"I(y := u, x := g2) = I(x:=g2,y:=u)" by (metis ass fun_upd_twist)
            from a[of "I(y:=u)"] a1 a2 a0 val_modify_val[of "u" "N" "I" "y"] assms(2) rec.prems(3)
            have "u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(y := u, x := g1)) h1) (RGL_game_sem N (I(y := u, x := g2)) h1)" by auto
            then show "u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(x:=g1,y:=u)) h1) (RGL_game_sem N (I(x:=g2,y := u)) h1)"
              using c1 c2 by auto
          qed
          show "fun_le (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g1, y := u)) h1)) (Lfp (World N) (\<lambda>u. RGL_game_sem N (I(x := g2, y := u)) h1))"
            unfolding fun_le_def Lfp_def Lfp_family_def
          proof fix xa 
            show "(if xa \<subseteq> World N then ambient_inter (World N) {\<phi> xa |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). \<forall>xa. RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa \<subseteq> \<phi> xa}}
           else undefined)
          \<subseteq> (if xa \<subseteq> World N then ambient_inter (World N) {\<phi> xa |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). \<forall>xa. RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa \<subseteq> \<phi> xa}}
              else undefined)"
            proof (cases "xa \<subseteq> World N")
              case True
              then show ?thesis apply (simp add:if_split) 
              proof -
                assume "xa \<subseteq> World N" 
                have "\<And>\<phi>. \<phi> \<in> effective_fn_of (World N) \<Longrightarrow> (\<forall>xa. RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa \<subseteq> \<phi> xa) 
                  \<Longrightarrow> (\<forall>xa. RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)"
                  using a4 unfolding fun_le_def by blast
                then have "{\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}
                  \<subseteq> {\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}" by auto
                then have "{\<phi> xa | \<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}
                  \<subseteq> {\<phi> xa| \<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}" by auto
                then show "ambient_inter (World N) {\<phi> xa |\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}
                  \<subseteq> ambient_inter (World N) {\<phi> xa |\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa \<subseteq> \<phi> xa)}" 
                  using ambient_inter_compat[where U="World N"] by auto
              qed
            next
              case False
              then show ?thesis by auto
            qed
          qed
      qed
    qed
  qed
qed
next
  case (drec y h1)
  then show ?case (* same as rec case *)
    unfolding RGL_fixpt_op_def monotone_op_of_def apply auto
  proof -
    fix xa assume a0:"xa \<in> effective_fn_of (World N)" and a1:"is_nbd_struct N" and a2:"is_val N I"
    show "RGL_game_sem N (I(x := xa)) (RGL_DRec y h1) \<in> effective_fn_of (World N)"
      using RGL_sem_wd(2) a1 a2 val_modify_val a0 by blast
  next
    fix g1 g2 assume a:"\<And>I. is_val N I \<Longrightarrow>
             (\<lambda>a. RGL_game_sem N (I(x := a)) h1) \<in> effective_fn_of (World N) \<rightarrow> effective_fn_of (World N) \<and>
             (\<forall>g1\<in>effective_fn_of (World N). \<forall>g2\<in>effective_fn_of (World N). fun_le g1 g2 \<longrightarrow> fun_le (RGL_game_sem N (I(x := g1)) h1) (RGL_game_sem N (I(x := g2)) h1))"
    and a1:"g1 \<in> effective_fn_of (World N)" and a2:"g2 \<in> effective_fn_of (World N)" and a0:"fun_le g1 g2"
    show conc:"fun_le (RGL_game_sem N (I(x := g1)) (RGL_DRec y h1)) (RGL_game_sem N (I(x := g2)) (RGL_DRec y h1))"
    proof (cases "x=y")
      case True
      then show ?thesis unfolding fun_le_def
      proof -
        assume ass:"x=y"
          from a1 RGL_DRec_sem[of "N""I(x := g1)""x""h1"] drec.prems val_modify_val[of "g1""N""I""x"] ass
          have a1':"RGL_game_sem N (I(x := g1)) (RGL_DRec y h1) = Gfp (World N) (RGL_fixpt_op N (I(x := g1)) x h1)" by auto
          from a2 RGL_DRec_sem[of "N""I(x := g2)""x""h1"] drec.prems val_modify_val[of "g2""N""I""x"] ass
          have a2':"RGL_game_sem N (I(x := g2)) (RGL_DRec y h1) = Gfp (World N) (RGL_fixpt_op N (I(x := g2)) x h1)" by auto 
          show "\<forall>xb. RGL_game_sem N (I(x := g1)) (RGL_DRec y h1) xb \<subseteq> RGL_game_sem N (I(x := g2)) (RGL_DRec y h1) xb"
            apply (simp add:a1' a2')
          proof fix xb 
            have c1:"\<And>u. I(x:=g1, x:=u) = I(x:=u)" by auto
            have c2:"\<And>u. I(x:=g2, x:=u) = I(x:=u)" by auto
            show "Gfp (World N) (RGL_fixpt_op N (I(x := g1)) x h1) xb \<subseteq> Gfp (World N) (RGL_fixpt_op N (I(x := g2)) x h1) xb"
              using c1 c2 unfolding RGL_fixpt_op_def by force
          qed
        qed
    next
      case False
      then show ?thesis
      proof -
        assume ass:"x\<noteq>y"
          from a1 RGL_DRec_sem[of "N""I(x := g1)""y""h1"] drec.prems val_modify_val[of "g1""N""I""x"] ass
          have a1':"RGL_game_sem N (I(x := g1)) (RGL_DRec y h1) = Gfp (World N) (RGL_fixpt_op N (I(x := g1)) y h1)" by auto
          from a2 RGL_DRec_sem[of "N""I(x := g2)""y""h1"] drec.prems val_modify_val[of "g2""N""I""x"] ass
          have a2':"RGL_game_sem N (I(x := g2)) (RGL_DRec y h1) = Gfp (World N) (RGL_fixpt_op N (I(x := g2)) y h1)" by auto         
          show "fun_le (RGL_game_sem N (I(x := g1)) (RGL_DRec y h1)) (RGL_game_sem N (I(x := g2)) (RGL_DRec y h1))"
            apply (simp add:a1' a2')
        proof -
          have a4:"\<And>u. u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(x:=g1,y:=u)) h1) (RGL_game_sem N (I(x:=g2,y := u)) h1)"
          proof - fix u
            have c1:"I(y := u, x := g1) = I(x:=g1,y:=u)" by (metis ass fun_upd_twist)
            have c2:"I(y := u, x := g2) = I(x:=g2,y:=u)" by (metis ass fun_upd_twist)
            from a[of "I(y:=u)"] a1 a2 a0 val_modify_val[of "u" "N" "I" "y"] assms(2) drec.prems(3)
            have "u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(y := u, x := g1)) h1) (RGL_game_sem N (I(y := u, x := g2)) h1)" by auto
            then show "u\<in>effective_fn_of (World N) \<Longrightarrow> fun_le (RGL_game_sem N (I(x:=g1,y:=u)) h1) (RGL_game_sem N (I(x:=g2,y := u)) h1)"
              using c1 c2 by auto
          qed
          show "fun_le (Gfp (World N) (RGL_fixpt_op N (I(x := g1)) y h1)) (Gfp (World N) (RGL_fixpt_op N (I(x := g2)) y h1))"
            unfolding fun_le_def Gfp_def Gfp_family_def
          proof fix xa
            show "(if xa \<subseteq> World N then \<Union> {\<phi> xa |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). \<forall>xa. \<phi> xa \<subseteq> RGL_fixpt_op N (I(x := g1)) y h1 \<phi> xa}} else undefined)
         \<subseteq> (if xa \<subseteq> World N then \<Union> {\<phi> xa |\<phi>. \<phi> \<in> {\<phi> \<in> effective_fn_of (World N). \<forall>xa. \<phi> xa \<subseteq> RGL_fixpt_op N (I(x := g2)) y h1 \<phi> xa}} else undefined)"
            proof (cases "xa \<subseteq> World N")
              case True
              then show ?thesis apply (simp add:if_split)
              proof -
                assume "xa \<subseteq> World N"
                have "\<And>\<phi>. \<phi> \<in> effective_fn_of (World N) \<Longrightarrow> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa) 
                  \<Longrightarrow> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa)"
                  using a4 unfolding fun_le_def by blast
                then have "{\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa)}
                  \<subseteq> {\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa)}" by auto
                then have "{\<phi> xa | \<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g1, y := \<phi>)) h1 xa)}
                  \<subseteq> {\<phi> xa| \<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_game_sem N (I(x := g2, y := \<phi>)) h1 xa)}" by auto
                then show "\<Union> {\<phi> xa |\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_fixpt_op N (I(x := g1)) y h1 \<phi> xa)} 
                          \<subseteq> \<Union> {\<phi> xa |\<phi>. \<phi> \<in> effective_fn_of (World N) \<and> (\<forall>xa. \<phi> xa \<subseteq> RGL_fixpt_op N (I(x := g2)) y h1 \<phi> xa)}"
                  unfolding RGL_fixpt_op_def by (simp add: Sup_subset_mono)
              qed
            next
              case False
              then show ?thesis by auto
            qed
          qed
      qed
    qed
  qed
  qed
next
  show "RGL_gm_nodual x h" using assms by simp
qed

(* f an RGL formula, f is "equivalent to" its normal form. RGL_sem f = RGL_sem (normalise f)
   definition normalise :: "" where ...
  
  *)

end